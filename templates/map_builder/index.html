<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        // Set API_BASE for subdirectory or root usage
        const API_BASE = "{{ api_base|default('') }}";
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mudra - Map Builder</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .builder-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .builder-header {
            background: #2c3e50;
            padding: 15px;
            border-bottom: 2px solid #34495e;
        }
        
        .builder-main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background: #34495e;
            padding: 15px;
            overflow-y: auto;
        }
        
        .canvas-container {
            flex: 1;
            background: #2c3e50;
            position: relative;
            overflow: auto;
        }
        
        .map-canvas {
            width: 100%;
            height: 100%;
            background: #1a252f;
            position: relative;
            min-width: 2000px;
            min-height: 2000px;
            padding-top: 10px;
            padding-left: 10px;
        }
        
        .map-canvas.gridlines-boxed {
            background-image: 
                linear-gradient(to right, rgba(52, 152, 219, 0.15) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(52, 152, 219, 0.15) 1px, transparent 1px);
            background-size: 50px 50px;
            background-position: 1005px 1005px;
        }
        
        .map-canvas.gridlines-centered {
            background-image: 
                linear-gradient(to right, rgba(52, 152, 219, 0.15) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(52, 152, 219, 0.15) 1px, transparent 1px);
            background-size: 50px 50px;
            background-position: 1030px 1030px;
        }
        
        .room-node {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #3498db;
            border: 2px solid #2980b9;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            font-size: 8px;
            text-align: center;
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .room-node.surrounding-area {
            background: #2c3e50;
            border: 2px solid #34495e;
            opacity: 0.7;
            cursor: default;
        }
        
        .room-node.surrounding-area:hover {
            border-color: #7f8c8d;
            transform: scale(1.05);
        }
        
        .room-node:hover {
            border-color: #00ff00;
            transform: scale(1.1);
        }
        
        .room-node.selected {
            outline: 1px solid #00ff00;
            outline-offset: 1px;
        }
        
        .room-node.multi-selected {
            outline: 1px solid #00ff00;
            outline-offset: 2px;
        }
        
        .exit-indicator {
            position: absolute;
            width: 0;
            height: 0;
            pointer-events: none;
        }
        
        .exit-up {
            top: 2px;
            right: 2px;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid #22e6e6;
        }
        
        .exit-down {
            top: 2px;
            left: 2px;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 6px solid #22e6e6;
        }
        
        .selection-box {
            position: absolute;
            border: 1px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            z-index: 999;
        }
        
        .room-tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            color: #ecf0f1;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 11px;
            white-space: pre-line;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.15s ease-in;
            line-height: 1.4;
        }
        
        .room-tooltip.show {
            opacity: 1;
        }
        
        .coord-display {
            position: fixed;
            bottom: 20px;
            left: 320px;
            background: rgba(44, 62, 80, 0.95);
            color: #00ff00;
            padding: 8px 16px;
            border-radius: 6px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            z-index: 1001;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }
        
        .coordinate-label {
            position: absolute;
            color: #95a5a6;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 10px;
            font-weight: bold;
            pointer-events: none;
            user-select: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }
        
        .coordinate-label.x-axis {
            top: 0px;
            transform: translateX(-50%);
        }
        
        .coordinate-label.y-axis {
            left: 0px;
            top: 0px;
            transform: translateY(-50%);
            writing-mode: horizontal-tb;
        }
        
        .connection-line {
            position: absolute;
            background: #95a5a6;
            height: 2px;
            transform-origin: left center;
            pointer-events: none;
        }
        
        .toolbar {
            background: #34495e;
            padding: 10px;
            border-bottom: 1px solid #4a5f7a;
        }
        
        .form-control, .form-select {
            background: #2c3e50;
            border: 1px solid #4a5f7a;
            color: white;
        }
        
        .form-control:focus, .form-select:focus {
            background: #2c3e50;
            border-color: #3498db;
            color: white;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
        }
        
        .btn-primary {
            background: #3498db;
            border-color: #2980b9;
        }
        
        .btn-primary:hover {
            background: #2980b9;
            border-color: #1f4e79;
        }
        
        .btn-success {
            background: #27ae60;
            border-color: #229954;
        }
        
        .btn-success:hover {
            background: #229954;
            border-color: #1e8449;
        }
        
        .btn-danger {
            background: #e74c3c;
            border-color: #c0392b;
        }
        
        .btn-danger:hover {
            background: #c0392b;
            border-color: #a93226;
        }
        
        .btn-warning {
            background: #f39c12;
            border-color: #e67e22;
            color: white;
        }
        
        .btn-warning:hover {
            background: #e67e22;
            border-color: #d35400;
            color: white;
        }
        
        .btn-warning:disabled {
            background: #7f8c8d;
            border-color: #6c7a89;
            color: #bdc3c7;
            opacity: 0.6;
        }
        
        .btn-secondary {
            background: #95a5a6;
            border-color: #7f8c8d;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #7f8c8d;
            border-color: #6c7a89;
        }
        
        .btn-secondary:disabled {
            background: #4a5f7a;
            border-color: #34495e;
            color: #7f8c8d;
            opacity: 0.6;
        }
        
        .modal-content {
            background: #2c3e50;
            color: white;
        }
        
        .modal-header {
            border-bottom: 1px solid #4a5f7a;
        }
        
        .modal-footer {
            border-top: 1px solid #4a5f7a;
        }
        
        .btn-outline-primary {
            color: #3498db;
            border-color: #3498db;
        }
        
        .btn-outline-primary:hover {
            background: #3498db;
            border-color: #3498db;
            color: white;
        }
        
        .btn-outline-secondary {
            color: #95a5a6;
            border-color: #95a5a6;
        }
        
        .btn-outline-secondary:hover {
            background: #95a5a6;
            border-color: #95a5a6;
            color: white;
        }
        
        .btn-outline-success {
            color: #27ae60;
            border-color: #27ae60;
        }
        
        .btn-outline-success:hover {
            background: #27ae60;
            border-color: #27ae60;
            color: white;
        }
        
        .form-check-input {
            background-color: #34495e;
            border-color: #4a5f7a;
        }
        
        .form-check-input:checked {
            background-color: #3498db;
            border-color: #3498db;
        }
        
        .form-check-input:focus {
            border-color: #3498db;
            box-shadow: 0 0 0 0.25rem rgba(52, 152, 219, 0.25);
        }
        
        .form-select-sm {
            background-color: #2c3e50;
            border-color: #4a5f7a;
            color: white;
            font-size: 0.875rem;
        }
        
        .form-select-sm:focus {
            background-color: #2c3e50;
            border-color: #3498db;
            color: white;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
        }
        
        .context-menu {
            position: fixed;
            background: #2c3e50;
            border: 1px solid #34495e;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 150px;
            padding: 4px 0;
        }
        
        .context-menu-item {
            padding: 8px 16px;
            color: #ecf0f1;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .context-menu-item:hover {
            background: #34495e;
        }
        
        .context-menu-item i {
            width: 16px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="builder-container">
        <!-- Header -->
        <div class="builder-header">
            <div class="d-flex justify-content-between align-items-center">
                <h3><i class="fas fa-hammer"></i> Mudra Map Builder</h3>
                <div class="d-flex align-items-center">
                    <div class="form-check form-switch me-4">
                        <input class="form-check-input" type="checkbox" id="surroundingAreasToggle" onchange="renderMap()">
                        <label class="form-check-label text-white" for="surroundingAreasToggle">
                            <i class="fas fa-map-marked-alt"></i> Surrounding Areas
                        </label>
                    </div>
                    <div class="form-check form-switch me-4">
                        <input class="form-check-input" type="checkbox" id="autoRoomToggle" onchange="toggleAutoRoom()" disabled>
                        <label class="form-check-label text-white" for="autoRoomToggle" id="autoRoomLabel" style="opacity: 0.5;">
                            <i class="fas fa-walking"></i> Auto Room
                        </label>
                    </div>
                    <div class="form-check form-switch me-4">
                        <input class="form-check-input" type="checkbox" id="showCoordinatesToggle" onchange="toggleCoordinateLabels()">
                        <label class="form-check-label text-white" for="showCoordinatesToggle">
                            <i class="fas fa-hashtag"></i> Show X/Y
                        </label>
                    </div>
                    <div class="form-check form-switch me-2">
                        <input class="form-check-input" type="checkbox" id="gridlinesToggle" onchange="toggleGridlines()" checked>
                        <label class="form-check-label text-white" for="gridlinesToggle">
                            <i class="fas fa-border-all"></i> Gridlines
                        </label>
                    </div>
                    <select class="form-select form-select-sm me-4" id="gridAlignmentSelect" onchange="updateGridAlignment()" style="width: 140px;">
                        <option value="boxed">Boxed</option>
                        <option value="centered">Centered</option>
                    </select>
                    <label class="me-2 text-white">Z-Level:</label>
                    <select class="form-select me-3" id="zLevelFilter" onchange="renderMap()" style="width: 100px;">
                        <option value="all">All</option>
                    </select>
                    <button class="btn btn-info btn-sm me-2" id="copySelectedBtn" onclick="copySelectedRooms()" style="display: none;">
                        <i class="fas fa-copy"></i> Copy Selected
                    </button>
                    <button class="btn btn-warning btn-sm me-2" id="autoExitBtn" onclick="autoExitSelectedRooms()" disabled>
                        <i class="fas fa-route"></i> Auto Exit
                    </button>
                    <button class="btn btn-secondary btn-sm me-2" id="undoBtn" onclick="undoLastAction()" disabled>
                        <i class="fas fa-undo"></i> Undo
                    </button>
                    <button class="btn btn-success me-2" onclick="saveMap()">
                        <i class="fas fa-save"></i> Save Map
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="builder-main">
            <!-- Sidebar -->
            <div class="sidebar">
                <h5>Current Area</h5>
                <select class="form-select mb-3" id="area-filter">
                </select>
                
                <h5>Rooms</h5>
                <select class="form-select" id="room-list" size="20" multiple>
                    <!-- Room list will be populated by JavaScript -->
                </select>
            </div>
            
            <!-- Canvas -->
            <div class="canvas-container">
                <div class="map-canvas" id="map-canvas">
                    <!-- Room nodes and connections will be rendered here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Room Editor Modal -->
    <div class="modal fade" id="roomModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Room Editor</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="roomForm">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="roomId" class="form-label">Room ID</label>
                                    <input type="text" class="form-control" id="roomId" required>
                                </div>
                                <div class="mb-3">
                                    <label for="roomName" class="form-label">Room Name</label>
                                    <input type="text" class="form-control" id="roomName" required>
                                </div>
                                <div class="mb-3">
                                    <label for="areaSelect" class="form-label">Area</label>
                                    <select class="form-select" id="areaSelect">
                                        <option value="">Select Area</option>
                                    </select>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="roomX" class="form-label">X Position (East/West)</label>
                                    <input type="number" class="form-control" id="roomX" value="0">
                                </div>
                                <div class="mb-3">
                                    <label for="roomY" class="form-label">Y Position (North/South)</label>
                                    <input type="number" class="form-control" id="roomY" value="0">
                                </div>
                                <div class="mb-3">
                                    <label for="roomZ" class="form-label">Z Position (Up/Down)</label>
                                    <input type="number" class="form-control" id="roomZ" value="0">
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="roomDescription" class="form-label">Description</label>
                            <textarea class="form-control" id="roomDescription" rows="4"></textarea>
                        </div>
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0">Exits</label>
                                <div class="btn-group btn-group-sm" role="group">
                                    <button type="button" class="btn btn-outline-primary" onclick="selectAllExits()">
                                        <i class="fas fa-check-double"></i> Select All
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary" onclick="clearAllExits()">
                                        <i class="fas fa-times"></i> Clear All
                                    </button>
                                    <button type="button" class="btn btn-outline-success" onclick="autoSelectExits()">
                                        <i class="fas fa-magic"></i> Auto Detect
                                    </button>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-2">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="exitNorth" onchange="handleExitChange('north', this.checked)">
                                        <label class="form-check-label" for="exitNorth">North</label>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="exitSouth" onchange="handleExitChange('south', this.checked)">
                                        <label class="form-check-label" for="exitSouth">South</label>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="exitEast" onchange="handleExitChange('east', this.checked)">
                                        <label class="form-check-label" for="exitEast">East</label>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="exitWest" onchange="handleExitChange('west', this.checked)">
                                        <label class="form-check-label" for="exitWest">West</label>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="exitUp" onchange="handleExitChange('up', this.checked)">
                                        <label class="form-check-label" for="exitUp">Up</label>
                                    </div>
                                </div>
                                <div class="col-md-2">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="exitDown" onchange="handleExitChange('down', this.checked)">
                                        <label class="form-check-label" for="exitDown">Down</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0">Doors</label>
                                <button type="button" class="btn btn-sm btn-info" onclick="showDoorHelp()">
                                    <i class="fas fa-question-circle"></i> Help
                                </button>
                            </div>
                            <div class="row" id="doorsList">
                                <div class="col-md-4 mb-2">
                                    <button type="button" class="btn btn-sm btn-outline-warning w-100" onclick="editDoor('north')">
                                        <i class="fas fa-door-closed"></i> North Door
                                    </button>
                                </div>
                                <div class="col-md-4 mb-2">
                                    <button type="button" class="btn btn-sm btn-outline-warning w-100" onclick="editDoor('south')">
                                        <i class="fas fa-door-closed"></i> South Door
                                    </button>
                                </div>
                                <div class="col-md-4 mb-2">
                                    <button type="button" class="btn btn-sm btn-outline-warning w-100" onclick="editDoor('east')">
                                        <i class="fas fa-door-closed"></i> East Door
                                    </button>
                                </div>
                                <div class="col-md-4 mb-2">
                                    <button type="button" class="btn btn-sm btn-outline-warning w-100" onclick="editDoor('west')">
                                        <i class="fas fa-door-closed"></i> West Door
                                    </button>
                                </div>
                                <div class="col-md-4 mb-2">
                                    <button type="button" class="btn btn-sm btn-outline-warning w-100" onclick="editDoor('up')">
                                        <i class="fas fa-door-closed"></i> Up Door
                                    </button>
                                </div>
                                <div class="col-md-4 mb-2">
                                    <button type="button" class="btn btn-sm btn-outline-warning w-100" onclick="editDoor('down')">
                                        <i class="fas fa-door-closed"></i> Down Door
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="roomLighting" class="form-label">Lighting</label>
                            <select class="form-select" id="roomLighting">
                                <option value="dark">Dark</option>
                                <option value="dim">Dim</option>
                                <option value="normal" selected>Normal</option>
                                <option value="bright">Bright</option>
                            </select>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" onclick="deleteRoom()" id="deleteBtn" style="display: none;">Delete</button>
                    <button type="button" class="btn btn-primary" onclick="saveRoom()">Save Room</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Door Editor Modal -->
    <div class="modal fade" id="doorModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Door Editor - <span id="doorDirection"></span></h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="doorForm">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="doorId" class="form-label">Door ID</label>
                                    <input type="text" class="form-control" id="doorId" required>
                                    <small class="text-muted">Unique identifier for this door</small>
                                </div>
                                <div class="mb-3">
                                    <label for="doorName" class="form-label">Door Name</label>
                                    <input type="text" class="form-control" id="doorName" required>
                                    <small class="text-muted">e.g., "Heavy Oak Door"</small>
                                </div>
                                <div class="mb-3">
                                    <label for="doorDescription" class="form-label">Description</label>
                                    <textarea class="form-control" id="doorDescription" rows="3"></textarea>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="doorKeyId" class="form-label">Key Template ID</label>
                                    <select class="form-select" id="doorKeyId">
                                        <option value="">No Key Required</option>
                                    </select>
                                    <small class="text-muted">Required if door is locked</small>
                                </div>
                                <div class="mb-3">
                                    <label for="doorLockDifficulty" class="form-label">Lock Difficulty: <span id="lockDifficultyValue">0</span></label>
                                    <input type="range" class="form-range" id="doorLockDifficulty" min="0" max="255" value="0" oninput="updateLockDifficultyLabel()">
                                    <div class="d-flex justify-content-between">
                                        <small class="text-muted">0 (Easy)</small>
                                        <small class="text-muted">100 (Normal)</small>
                                        <small class="text-muted">255 (Magical)</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Door Flags</label>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagClosed">
                                        <label class="form-check-label" for="flagClosed">
                                            Closed
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Door starts closed"></i>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagLocked">
                                        <label class="form-check-label" for="flagLocked">
                                            Locked
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Door is locked (requires key)"></i>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagPickProof">
                                        <label class="form-check-label" for="flagPickProof">
                                            Pick Proof
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Cannot be picked"></i>
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagPassProof">
                                        <label class="form-check-label" for="flagPassProof">
                                            Pass Proof
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Cannot pass through (impassable)"></i>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagSecret">
                                        <label class="form-check-label" for="flagSecret">
                                            Secret
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Hidden door (requires search)"></i>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagHidden">
                                        <label class="form-check-label" for="flagHidden">
                                            Hidden
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Not visible in room description"></i>
                                        </label>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagNoLock">
                                        <label class="form-check-label" for="flagNoLock">
                                            No Lock
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Door cannot be locked"></i>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagNoKnock">
                                        <label class="form-check-label" for="flagNoKnock">
                                            No Knock
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Knock spell won't work"></i>
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="flagNoClose">
                                        <label class="form-check-label" for="flagNoClose">
                                            No Close
                                            <i class="fas fa-info-circle text-info" data-bs-toggle="tooltip" title="Door cannot be closed"></i>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger" onclick="deleteDoor()" id="deleteDoorBtn">Delete Door</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveDoor()">Save Door</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div id="contextMenu" class="context-menu" style="display: none;">
        <div class="context-menu-item" onclick="changeSelectedRoomNames()">
            <i class="fas fa-edit"></i> Change Name
        </div>
    </div>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Global variables
        let rooms = [];
        let areas = [];
        let selectedRoom = null;
        let roomModal = null;
        let doorModal = null;
        let currentDoorDirection = null;
        let availableKeys = [];
        let tooltip = null;
        let multiSelectedRooms = [];
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionBox = null;
        let justFinishedDrag = false;
        let isDraggingRoom = false;
        let draggedRoom = null;
        let draggedNode = null;
        let draggedRooms = []; // For multi-room dragging
        let draggedNodes = []; // For multi-room dragging
        let dragOffset = { x: 0, y: 0 };
        
        // Canvas constants
        const CANVAS_PADDING = 10; // Padding offset for canvas
        const CANVAS_CENTER = 1000; // Canvas center offset
        const GRID_SIZE = 50; // Size of each grid cell
        
        // Undo history (max 3 actions)
        let undoHistory = [];
        const MAX_UNDO_STEPS = 3;
        
        // Auto Room mode
        let autoRoomMode = false;
        
        // Initialize the map builder
        document.addEventListener('DOMContentLoaded', function() {
            roomModal = new bootstrap.Modal(document.getElementById('roomModal'));
            doorModal = new bootstrap.Modal(document.getElementById('doorModal'));
             
             // Create tooltip element
             tooltip = document.createElement('div');
             tooltip.className = 'room-tooltip';
             document.body.appendChild(tooltip);
             
             // Load available keys
             loadKeys();
             
             // Create coordinate display element
             const coordDisplay = document.createElement('div');
             coordDisplay.className = 'coord-display';
             coordDisplay.id = 'coord-display';
             coordDisplay.textContent = 'X: 0, Y: 0, Z: 0';
             document.body.appendChild(coordDisplay);
             
             // Add click handler to canvas for creating new rooms
             const canvas = document.getElementById('map-canvas');
             canvas.addEventListener('click', handleCanvasClick);
             
             // Add drag selection handlers
             canvas.addEventListener('mousedown', handleSelectionStart);
             canvas.addEventListener('mousemove', handleCanvasDrag);
             canvas.addEventListener('mouseup', handleCanvasMouseUp);
             canvas.addEventListener('mouseleave', handleCanvasMouseUp);
             
             // Add mousemove to update coordinate display
             canvas.addEventListener('mousemove', updateCoordDisplay);
             
             // Add keyboard handler for Delete key
             document.addEventListener('keydown', handleKeyPress);
             
             // Add context menu handlers
             document.addEventListener('click', hideContextMenu);
             document.addEventListener('contextmenu', handleContextMenu);
             
             // Initialize gridlines (enabled by default with boxed alignment)
             canvas.classList.add('gridlines-boxed');
             
            loadAreas();
            loadRooms();
        });
        
        // Load areas from API
        async function loadAreas() {
            try {
                const response = await fetch(`${API_BASE}/api/areas`);
                areas = await response.json();
                populateAreaSelect();
                renderAreaList();
            } catch (error) {
                console.error('Error loading areas:', error);
            }
        }
        
        // Load rooms from API
        async function loadRooms() {
            try {
                const response = await fetch(`${API_BASE}/api/rooms`);
                rooms = await response.json();
                 const selectedAreaId = document.getElementById('area-filter')?.value || null;
                 renderRoomList(selectedAreaId);
                renderMap();
            } catch (error) {
                console.error('Error loading rooms:', error);
            }
        }
        
        // Toggle gridlines on/off
        function toggleGridlines() {
            const canvas = document.getElementById('map-canvas');
            const toggle = document.getElementById('gridlinesToggle');
            const alignment = document.getElementById('gridAlignmentSelect').value;
            
            // Remove both gridline classes
            canvas.classList.remove('gridlines-boxed', 'gridlines-centered');
            
            if (toggle.checked) {
                // Add the appropriate class based on alignment
                if (alignment === 'centered') {
                    canvas.classList.add('gridlines-centered');
                } else {
                    canvas.classList.add('gridlines-boxed');
                }
            }
        }
        
        // Toggle coordinate labels on/off
        function toggleCoordinateLabels() {
            const canvas = document.getElementById('map-canvas');
            const toggle = document.getElementById('showCoordinatesToggle');
            
            // Remove all existing coordinate labels
            const existingLabels = canvas.querySelectorAll('.coordinate-label');
            existingLabels.forEach(label => label.remove());
            
            if (toggle.checked) {
                // Determine the range of coordinates to display
                // Show labels from -20 to +20 for both X and Y axes
                const minCoord = -20;
                const maxCoord = 20;
                
                // Create X-axis labels (along the top, in the padding area)
                for (let x = minCoord; x <= maxCoord; x++) {
                    if (x === 0) continue; // Skip 0 for cleaner look
                    const label = document.createElement('div');
                    label.className = 'coordinate-label x-axis';
                    label.textContent = x;
                    // Position in top padding area, accounting for canvas padding
                    label.style.left = `${x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING}px`;
                    label.style.top = '2px';
                    canvas.appendChild(label);
                }
                
                // Create Y-axis labels (along the left, in the padding area)
                for (let y = minCoord; y <= maxCoord; y++) {
                    if (y === 0) continue; // Skip 0 for cleaner look
                    const label = document.createElement('div');
                    label.className = 'coordinate-label y-axis';
                    label.textContent = y;
                    // Position in left padding area, accounting for canvas padding
                    label.style.left = '2px';
                    label.style.top = `${-y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING}px`;
                    canvas.appendChild(label);
                }
                
                // Add origin label (0,0) at the intersection
                const originLabel = document.createElement('div');
                originLabel.className = 'coordinate-label';
                originLabel.textContent = '0';
                originLabel.style.left = '0px';
                originLabel.style.top = '0px';
                originLabel.style.color = '#3498db';
                canvas.appendChild(originLabel);
            }
        }
        
        // Update grid alignment
        function updateGridAlignment() {
            const toggle = document.getElementById('gridlinesToggle');
            
            // Only update if gridlines are currently enabled
            if (toggle.checked) {
                toggleGridlines();
            }
        }
        
        // Toggle Auto Room mode
        function toggleAutoRoom() {
            const toggle = document.getElementById('autoRoomToggle');
            autoRoomMode = toggle.checked;
            
            if (autoRoomMode) {
                console.log('========================================');
                console.log('Auto Room mode ENABLED');
                console.log('Use numpad keys to create rooms:');
                console.log('  8 = North, 2 = South');
                console.log('  6 = East, 4 = West');
                console.log('  9 = NE, 7 = NW, 3 = SE, 1 = SW');
                console.log('  + = Up, - = Down');
                console.log('Selected room:', selectedRoom ? selectedRoom.room_id : 'none');
                console.log('========================================');
            } else {
                console.log('Auto Room mode DISABLED');
            }
        }
        
        // Update Auto Room toggle state based on selection
        function updateAutoRoomToggle() {
            const toggle = document.getElementById('autoRoomToggle');
            const label = document.getElementById('autoRoomLabel');
            
            // Enable only if exactly one room is selected and not in multi-select
            const canEnable = selectedRoom && multiSelectedRooms.length <= 1;
            
            toggle.disabled = !canEnable;
            label.style.opacity = canEnable ? '1' : '0.5';
            
            // Turn off auto room mode if conditions are no longer met
            if (!canEnable && autoRoomMode) {
                toggle.checked = false;
                autoRoomMode = false;
            }
        }
        
        // Create a room in the given direction using Auto Room mode
        async function createAutoRoom(direction) {
            if (!selectedRoom) return;
            
            const newX = selectedRoom.x + direction.x;
            const newY = selectedRoom.y + direction.y;
            const newZ = (selectedRoom.z || 0) + direction.z;
            
            // Check if room already exists at target location
            const existingRoom = rooms.find(r => 
                r.x === newX && r.y === newY && (r.z || 0) === newZ
            );
            
            if (existingRoom) {
                console.log(`❌ Room already exists at (${newX}, ${newY}, ${newZ}). Cannot create.`);
                console.log(`   Existing room: ${existingRoom.room_id} - ${existingRoom.name}`);
                
                // Briefly flash the existing room
                const nodes = document.querySelectorAll('.room-node');
                nodes.forEach(n => {
                    if (n.innerHTML.includes(existingRoom.name) && 
                        n.style.left === `${existingRoom.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING}px` &&
                        n.style.top === `${-existingRoom.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING}px`) {
                        // Flash the node
                        n.style.backgroundColor = '#e74c3c';
                        n.style.transform = 'scale(1.2)';
                        setTimeout(() => {
                            n.style.backgroundColor = '';
                            n.style.transform = '';
                        }, 300);
                    }
                });
                
                return;
            }
            
            // Generate new room ID
            const nextRoomId = getNextRoomId();
            
            // Create room data
            const roomData = {
                room_id: nextRoomId,
                name: `Room ${nextRoomId}`,
                description: `A room ${direction.name} of ${selectedRoom.name}.`,
                area_id: selectedRoom.area_id || null,
                x: newX,
                y: newY,
                z: newZ,
                exits: {},
                lighting: selectedRoom.lighting || 'normal'
            };
            
            // Determine the opposite direction for reciprocal exit
            const oppositeDirections = {
                'north': 'south',
                'south': 'north',
                'east': 'west',
                'west': 'east',
                'northeast': 'southwest',
                'northwest': 'southeast',
                'southeast': 'northwest',
                'southwest': 'northeast',
                'up': 'down',
                'down': 'up'
            };
            
            const oppositeDir = oppositeDirections[direction.name];
            
            // Add exit from new room back to current room
            if (oppositeDir) {
                roomData.exits[oppositeDir] = selectedRoom.room_id;
            }
            
            try {
                // Create the new room
                const response = await fetch('/api/rooms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(roomData)
                });
                
                if (response.ok) {
                    const newRoom = await response.json();
                    
                    // Add exit from current room to new room
                    const updatedExits = { ...(selectedRoom.exits || {}) };
                    updatedExits[direction.name] = newRoom.room_id;
                    
                    // Update current room with new exit
                    await fetch(`/api/rooms/${selectedRoom.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            room_id: selectedRoom.room_id,
                            name: selectedRoom.name,
                            description: selectedRoom.description,
                            area_id: selectedRoom.area_id,
                            x: selectedRoom.x,
                            y: selectedRoom.y,
                            z: selectedRoom.z || 0,
                            exits: updatedExits,
                            lighting: selectedRoom.lighting || 'normal'
                        })
                    });
                    
                    // Reload rooms and re-render
                    await loadRooms();
                    renderMap();
                    
                    // Select the newly created room to continue walking
                    const freshNewRoom = rooms.find(r => r.room_id === newRoom.room_id);
                    if (freshNewRoom) {
                        selectedRoom = freshNewRoom;
                        
                        // Highlight the new room
                        const nodes = document.querySelectorAll('.room-node');
                        nodes.forEach(n => {
                            n.classList.remove('selected');
                            if (n.innerHTML.includes(freshNewRoom.name) && 
                                n.style.left === `${freshNewRoom.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING}px` &&
                                n.style.top === `${-freshNewRoom.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING}px`) {
                                n.classList.add('selected');
                            }
                        });
                        
                        updateSelectionDisplay();
                    }
                    
                    console.log(`✓ Created room ${newRoom.room_id} at (${newX}, ${newY}, ${newZ})`);
                } else {
                    const errorText = await response.text();
                    console.error('❌ Error creating room:', errorText);
                    alert('Error creating room: ' + errorText);
                }
            } catch (error) {
                console.error('❌ Error creating auto room:', error);
                alert('Error creating auto room: ' + error.message);
            }
        }
        
        // Populate area select dropdown
        function populateAreaSelect() {
            const select = document.getElementById('areaSelect');
            select.innerHTML = '<option value="">Select Area</option>';
            areas.forEach(area => {
                const option = document.createElement('option');
                option.value = area.id;
                option.textContent = area.name;
                select.appendChild(option);
            });
        }
        
        // Render room list in sidebar
         function renderRoomList(filterAreaId = null) {
             const select = document.getElementById('room-list');
             select.innerHTML = '<option value="">Select a room...</option>';
             
             // Filter rooms by area if specified
             const filteredRooms = !filterAreaId 
                 ? rooms 
                 : rooms.filter(room => {
                     const area = areas.find(a => a.id === room.area_id);
                     return area && area.area_id === filterAreaId;
                 });
             
             // Sort rooms by room_id
             filteredRooms.sort((a, b) => a.room_id.localeCompare(b.room_id));
             
             filteredRooms.forEach(room => {
                 const option = document.createElement('option');
                 option.value = room.id;
                 option.textContent = `${room.room_id} - ${room.name} (${room.x}, ${room.y}, ${room.z || 0})`;
                 select.appendChild(option);
             });
             
             // Add change handler to select room on canvas
             select.onchange = function() {
                 if (this.value) {
                    const selectedOptions = Array.from(this.selectedOptions);
                    const selectedRoomIds = selectedOptions.map(option => parseInt(option.value));
                    multiSelectedRooms = selectedRoomIds;
                    selectedRoom = rooms.find(r => r.id === selectedRoomIds[0]) || null;
                    displayClearSelectedRooms();
                    selectRoomsByIds(selectedRoomIds);
                 } else {
                    multiSelectedRooms = [];
                    selectedRoom = null;
                    displayClearSelectedRooms();
                    selectRoomsByIds([]);
                 }
             };
        }
        
        // Render area list in sidebar
        function renderAreaList() {
             const select = document.getElementById('area-filter');
             select.innerHTML = '';
            
            areas.forEach(area => {
                 const option = document.createElement('option');
                 option.value = area.area_id;
                 option.textContent = area.name;
                 select.appendChild(option);
             });
             
             // Select the first area by default
             if (areas.length > 0) {
                 select.value = areas[0].area_id;
             }
             
             // Add change event listener to filter rooms
             select.addEventListener('change', filterRoomsByArea);
         }
         
         // Filter rooms by selected area
         function filterRoomsByArea() {
             const selectedAreaId = document.getElementById('area-filter').value;
             
             // Clear selections when changing area filter
             clearMultiSelection();
             
             renderRoomList(selectedAreaId);
             renderMap(); // Redraw map to show filtered area
        }
        
        // Render map canvas
        function renderMap() {
            const canvas = document.getElementById('map-canvas');
            canvas.innerHTML = '';
            
            // Reset selection box since canvas was cleared
            selectionBox = null;
            
            // Get current filters
            const zFilter = document.getElementById('zLevelFilter').value;
            const areaFilter = document.getElementById('area-filter')?.value || null;
            const showSurrounding = document.getElementById('surroundingAreasToggle')?.checked || false;
            
            // Populate Z-level filter if empty
            const zLevels = [...new Set(rooms.map(r => r.z || 0))].sort((a, b) => a - b);
            const zLevelSelect = document.getElementById('zLevelFilter');
            const currentValue = zLevelSelect.value;
            zLevelSelect.innerHTML = '<option value="all">All</option>';
            zLevels.forEach(z => {
                const option = document.createElement('option');
                option.value = z;
                option.textContent = z;
                zLevelSelect.appendChild(option);
            });
            zLevelSelect.value = currentValue;
            
            // Filter rooms by Z-level and area
            let filteredRooms = rooms;
            
            // Filter by Z-level
            if (zFilter !== 'all') {
                filteredRooms = filteredRooms.filter(r => (r.z || 0) === parseInt(zFilter));
            }
            
            // Filter by area
            if (areaFilter) {
                filteredRooms = filteredRooms.filter(room => {
                    const area = areas.find(a => a.id === room.area_id);
                    return area && area.area_id === areaFilter;
                });
            }
            
            // Get surrounding area rooms if toggle is on
            let surroundingRooms = [];
            if (showSurrounding && filteredRooms.length > 0) {
                // Find rooms within 30 units of any filtered room
                surroundingRooms = rooms.filter(room => {
                    // Skip if room is already in filtered rooms
                    if (filteredRooms.some(fr => fr.id === room.id)) return false;
                    
                    // Skip if not on same Z-level
                    if (zFilter !== 'all' && (room.z || 0) !== parseInt(zFilter)) return false;
                    
                    // Check if within 30 units of any filtered room
                    return filteredRooms.some(fr => {
                        const distance = Math.sqrt(
                            Math.pow(room.x - fr.x, 2) + 
                            Math.pow(room.y - fr.y, 2) + 
                            Math.pow((room.z || 0) - (fr.z || 0), 2)
                        );
                        return distance <= 30;
                    });
                });
            }
            
            // Render room nodes
             filteredRooms.forEach(room => {
                const node = document.createElement('div');
                node.className = 'room-node';
                 node.style.left = (room.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING) + 'px';
                 node.style.top = (-room.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING) + 'px';
                 node.innerHTML = `${room.name}`;
                 
                 // Add exit indicators for up/down
                 if (room.exits) {
                     if (room.exits.up) {
                         const upArrow = document.createElement('div');
                         upArrow.className = 'exit-indicator exit-up';
                         node.appendChild(upArrow);
                     }
                     if (room.exits.down) {
                         const downArrow = document.createElement('div');
                         downArrow.className = 'exit-indicator exit-down';
                         node.appendChild(downArrow);
                     }
                 }
                 
                 // Restore selected state if this is the selected room
                 if (selectedRoom && selectedRoom.id === room.id) {
                     node.classList.add('selected');
                 }
                 
                 // Restore multi-selected state
                 if (multiSelectedRooms.includes(room.id)) {
                     node.classList.add('multi-selected');
                 }
                 
                 // Add hover events for custom tooltip
                 node.addEventListener('mouseenter', (e) => showTooltip(e, room));
                 node.addEventListener('mouseleave', hideTooltip);
                 node.addEventListener('mousemove', updateTooltipPosition);
                 
                 // Add drag handlers for moving rooms (Ctrl+drag)
                 node.addEventListener('mousedown', (e) => handleRoomDragStart(e, room, node));
                 
                // Single click to select, double click to edit
                node.onclick = (e) => {
                    // Prevent event bubbling
                    e.stopPropagation();
                    
                    // Ctrl+Click: Toggle room in/out of multi-selection
                    if (e.ctrlKey) {
                        const roomIndex = multiSelectedRooms.indexOf(room.id);
                        if (roomIndex > -1) {
                            // Remove from selection
                            multiSelectedRooms.splice(roomIndex, 1);
                            if (selectedRoom && selectedRoom.id === room.id) {
                                // If this was the main selected room, pick another from multi-selection or clear
                                selectedRoom = multiSelectedRooms.length > 0 
                                    ? rooms.find(r => r.id === multiSelectedRooms[0]) 
                                    : null;
                            }
                        } else {
                            // Add to selection
                            multiSelectedRooms.push(room.id);
                            selectedRoom = room;
                        }
                        updateMultiSelection();
                    }
                    // Shift+Click: Add to multi-selection (don't remove others)
                    else if (e.shiftKey) {
                        if (!multiSelectedRooms.includes(room.id)) {
                            multiSelectedRooms.push(room.id);
                        }
                        selectedRoom = room;
                        updateMultiSelection();
                    }
                    // Normal click: Clear all selections and select only this room
                    else {
                        multiSelectedRooms = [];
                        selectRoomVisual(room, node);
                    }
                };
                node.ondblclick = (e) => {
                    if (!e.ctrlKey && !e.shiftKey) {
                        openRoomEditor(room);
                    }
                };
                canvas.appendChild(node);
            });
            
            // Render surrounding area rooms (if toggle is on)
            surroundingRooms.forEach(room => {
                const node = document.createElement('div');
                node.className = 'room-node surrounding-area';
                node.style.left = (room.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING) + 'px';
                node.style.top = (-room.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING) + 'px';
                node.innerHTML = `${room.name}`;
                
                // Add exit indicators for up/down
                if (room.exits) {
                    if (room.exits.up) {
                        const upArrow = document.createElement('div');
                        upArrow.className = 'exit-indicator exit-up';
                        node.appendChild(upArrow);
                    }
                    if (room.exits.down) {
                        const downArrow = document.createElement('div');
                        downArrow.className = 'exit-indicator exit-down';
                        node.appendChild(downArrow);
                    }
                }
                
                // Add hover events for tooltip
                node.addEventListener('mouseenter', (e) => showTooltip(e, room));
                node.addEventListener('mouseleave', hideTooltip);
                node.addEventListener('mousemove', updateTooltipPosition);
                
                // Note: No drag/select handlers for surrounding rooms - they're read-only
                
                canvas.appendChild(node);
            });
            
            // Render connections (skip up/down as they have arrow indicators)
            filteredRooms.forEach(room => {
                if (room.exits) {
                    Object.entries(room.exits).forEach(([direction, targetRoomId]) => {
                        // Skip up/down exits - they're shown with arrows on the room nodes
                        if (direction === 'up' || direction === 'down') return;
                        
                        const targetRoom = rooms.find(r => r.room_id === targetRoomId);
                        // Only draw connection if target room is also in filtered set
                        if (targetRoom && filteredRooms.some(fr => fr.id === targetRoom.id)) {
                            drawConnection(room, targetRoom, direction);
                        }
                    });
                }
            });
            
            // Restore coordinate labels if they were enabled
            const showCoordinatesToggle = document.getElementById('showCoordinatesToggle');
            if (showCoordinatesToggle && showCoordinatesToggle.checked) {
                // Re-create the coordinate labels since canvas was cleared
                toggleCoordinateLabels();
            }
        }
        
         // Draw connection between rooms (horizontal connections only - up/down use arrows)
        function drawConnection(room1, room2, direction) {
            const canvas = document.getElementById('map-canvas');
            const line = document.createElement('div');
            line.className = 'connection-line';
            
             // Calculate center points of 40x40px rooms with GRID_SIZE spacing on both axes
             const x1 = room1.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING + (GRID_SIZE / 2 - 5);
             const y1 = -room1.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING + (GRID_SIZE / 2 - 5);
             const x2 = room2.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING + (GRID_SIZE / 2 - 5);
             const y2 = -room2.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING + (GRID_SIZE / 2 - 5);
             
             // Calculate angle and distance
             const angle = Math.atan2(y2 - y1, x2 - x1);
             const angleDeg = angle * 180 / Math.PI;
             const fullLength = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
             
             // Use smaller offset (15px) to ensure lines are visible even for close rooms
             const lineOffset = 15;
             const length = Math.max(fullLength - (lineOffset * 2), 2); // Minimum 2px line
             
             // Calculate starting point (offset from center by lineOffset)
             const startX = x1 + Math.cos(angle) * lineOffset;
             const startY = y1 + Math.sin(angle) * lineOffset;
             
             line.style.left = startX + 'px';
             line.style.top = startY + 'px';
            line.style.width = length + 'px';
             line.style.transform = `rotate(${angleDeg}deg)`;
            
            canvas.appendChild(line);
        }
        
        // Show tooltip for room
        function showTooltip(event, room) {
            // Build tooltip content
            let tooltipText = `Coords: (${room.x}, ${room.y}, ${room.z || 0})\nRoom ID: ${room.room_id}`;
            
            // Add area information
            if (room.area_id) {
                const area = areas.find(a => a.id === room.area_id);
                if (area) {
                    tooltipText += `\nArea: ${area.name}`;
                }
            }
            
            // Add exits information
            if (room.exits && Object.keys(room.exits).length > 0) {
                tooltipText += '\n\nExits:';
                Object.entries(room.exits).forEach(([direction, targetRoomId]) => {
                    const targetRoom = rooms.find(r => r.room_id === targetRoomId);
                    const targetName = targetRoom ? targetRoom.name : 'Unknown';
                    tooltipText += `\n  ${direction} → ${targetRoomId} (${targetName})`;
                });
            } else {
                tooltipText += '\n\nExits: None';
            }
            
            tooltip.textContent = tooltipText;
            tooltip.style.left = event.pageX + 15 + 'px';
            tooltip.style.top = event.pageY + 15 + 'px';
            
            // Use setTimeout to apply the show class after a brief delay for faster appearance
            setTimeout(() => {
                tooltip.classList.add('show');
            }, 10);
        }
        
        // Hide tooltip
        function hideTooltip() {
            tooltip.classList.remove('show');
        }
        
        // Update tooltip position on mouse move
        function updateTooltipPosition(event) {
            tooltip.style.left = event.pageX + 15 + 'px';
            tooltip.style.top = event.pageY + 15 + 'px';
        }
        
        // Update coordinate display as mouse moves
        function updateCoordDisplay(event) {
            const coordDisplay = document.getElementById('coord-display');
            if (!coordDisplay) return;
            
            // Calculate grid coordinates from mouse position relative to the canvas
            const canvas = document.getElementById('map-canvas');
            const rect = canvas.getBoundingClientRect();
            const scrollLeft = canvas.scrollLeft || 0;
            const scrollTop = canvas.scrollTop || 0;
            
            const clickX = event.clientX - rect.left + scrollLeft;
            const clickY = event.clientY - rect.top + scrollTop;
            
            const gridX = Math.round((clickX - (CANVAS_CENTER + CANVAS_PADDING)) / GRID_SIZE);
            const gridY = Math.round(-(clickY - (CANVAS_CENTER + CANVAS_PADDING)) / GRID_SIZE);
            
            // Get current Z-level
            const zFilter = document.getElementById('zLevelFilter').value;
            const gridZ = (zFilter === 'all') ? 0 : parseInt(zFilter);
            
            // Update display with coordinates and selection info
            let displayText = `X: ${gridX}, Y: ${gridY}, Z: ${gridZ}`;
            
            // Add selection information
            if (multiSelectedRooms.length > 1) {
                displayText += ` | ${multiSelectedRooms.length} Rooms Selected`;
            } else if (multiSelectedRooms.length === 1) {
                const room = rooms.find(r => r.id === multiSelectedRooms[0]);
                if (room) {
                    displayText += ` | Selected: ${room.name} (X: ${room.x}, Y: ${room.y}, Z: ${room.z})`;
                }
            } else if (selectedRoom) {
                displayText += ` | Selected: ${selectedRoom.name} (X: ${selectedRoom.x}, Y: ${selectedRoom.y}, Z: ${selectedRoom.z})`;
            }
            
            coordDisplay.textContent = displayText;
        }
        
        // Update selection display without requiring mouse movement
        function updateSelectionDisplay() {
            const coordDisplay = document.getElementById('coord-display');
            if (!coordDisplay) return;

            // Get current coordinates from display or use defaults
            const currentText = coordDisplay.textContent;
            const coordMatch = currentText.match(/X: (-?\d+), Y: (-?\d+), Z: (-?\d+)/);

            let displayText = coordMatch ? coordMatch[0] : 'X: 0, Y: 0, Z: 0';

            // Add selection information
            if (multiSelectedRooms.length > 1) {
                displayText += ` | ${multiSelectedRooms.length} Rooms Selected`;
            } else if (multiSelectedRooms.length === 1) {
                const room = rooms.find(r => r.id === multiSelectedRooms[0]);
                if (room) {
                    displayText += ` | Selected: ${room.name} (X: ${room.x}, Y: ${room.y}, Z: ${room.z})`;
                }
            } else if (selectedRoom) {
                displayText += ` | Selected: ${selectedRoom.name} (X: ${selectedRoom.x}, Y: ${selectedRoom.y}, Z: ${selectedRoom.z})`;
            }

            coordDisplay.textContent = displayText;

            // Update sidebar room list selection to match canvas selection
            const roomList = document.getElementById('room-list');
            if (roomList) {
                // Remove 'selected' class from all options
                for (let i = 0; i < roomList.options.length; i++) {
                    roomList.options[i].classList.remove('selected');
                    roomList.options[i].selected = false;
                }

                if (multiSelectedRooms.length > 0) {
                    // Select all options whose value is in multiSelectedRooms
                    for (let i = 0; i < roomList.options.length; i++) {
                        if (multiSelectedRooms.includes(Number.parseInt(roomList.options[i].value))) {
                            roomList.options[i].selected = true;
                            roomList.options[i].classList.add('selected');
                        }
                    }
                } else if (selectedRoom) {
                    for (let i = 0; i < roomList.options.length; i++) {
                        if (roomList.options[i].value == selectedRoom.id) {
                            roomList.options[i].selected = true;
                            roomList.options[i].classList.add('selected');
                            break;
                        }
                    }
                } else {
                    // Default to placeholder
                    if (roomList.options.length > 0) {
                        roomList.options[0].selected = true;
                    }
                }
            }
        }
        
        // Select a room visually (single click)
        function selectRoomVisual(room, node) {
            // Don't select if we just finished dragging a room
            if (justFinishedDrag) {
                justFinishedDrag = false;
                return;
            }
            
            selectedRoom = room;
            
            // Remove all selected classes
            displayClearSelectedRooms();
            
            // Add selected class to clicked node
            node.classList.add('selected');
            
            // Update selection display
            updateSelectionDisplay();
            
            // Update auto room toggle state
            updateAutoRoomToggle();
        }

        function displayClearSelectedRooms() {
            // Remove all selected classes
            document.querySelectorAll('.room-node').forEach(n => {
                n.classList.remove('selected');
                n.classList.remove('multi-selected');
            });
        }

        function selectRoomsByIds(roomIds) {
            displayClearSelectedRooms();
            roomIds.forEach(id => {
                selectRoomById(id, false);
            });
        }

        // Select a room by ID (from dropdown or other source)
        function selectRoomById(roomId, remove = true) {
            const room = rooms.find(r => r.id === roomId);
            if (!room) return;
            
            selectedRoom = room;

            if(remove) {
                displayClearSelectedRooms();
            }

            // Find and highlight the room node on canvas
            const nodes = document.querySelectorAll('.room-node');
            nodes.forEach(node => {
                // Match by checking innerHTML content (not ideal but works)
                if (node.innerHTML.includes(room.name) && 
                    node.style.left === `${room.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING}px` &&
                    node.style.top === `${-room.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING}px`) {
                    node.classList.add('selected');
                    if(!multiSelectedRooms.includes(room.id)) {
                        multiSelectedRooms.push(room.id);
                    }
                    // Scroll node into view
                    node.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                }
            });
            
            // Update selection display
            updateSelectionDisplay();
            
            // Update auto room toggle state
            updateAutoRoomToggle();
        }
        
        // Open room editor (double click)
        function openRoomEditor(room) {
            selectedRoom = room;
            
            // Populate form
            document.getElementById('roomId').value = room.room_id;
            document.getElementById('roomName').value = room.name;
            document.getElementById('roomDescription').value = room.description;
            document.getElementById('areaSelect').value = room.area_id || '';
            document.getElementById('roomX').value = room.x;
            document.getElementById('roomY').value = room.y;
            document.getElementById('roomZ').value = room.z || 0;
            
            // Set exits (check if exit exists and has a room_id)
            document.getElementById('exitNorth').checked = room.exits && room.exits.north ? true : false;
            document.getElementById('exitSouth').checked = room.exits && room.exits.south ? true : false;
            document.getElementById('exitEast').checked = room.exits && room.exits.east ? true : false;
            document.getElementById('exitWest').checked = room.exits && room.exits.west ? true : false;
            document.getElementById('exitUp').checked = room.exits && room.exits.up ? true : false;
            document.getElementById('exitDown').checked = room.exits && room.exits.down ? true : false;
            
            // Set lighting
            document.getElementById('roomLighting').value = room.lighting || 'normal';
            
            // Update door button states
            updateDoorButtons();
            
            // Show delete button
            document.getElementById('deleteBtn').style.display = 'inline-block';
            
            roomModal.show();
        }
        
        // Select a room from sidebar (kept for compatibility)
        function selectRoom(room) {
            // Select the room visually on the canvas
            if (room && room.id) {
                selectRoomById(room.id);
            }
        }
        
         // Handle canvas click for creating new rooms
         async function handleCanvasClick(event) {
             // Ignore clicks on room nodes (they have their own handlers)
             if (event.target.classList.contains('room-node')) {
                 return;
             }
             
             // Don't create room if we just finished a drag
             if (justFinishedDrag) {
                 justFinishedDrag = false;
                 return;
             }
             
             // Calculate grid coordinates from click position
             // Formula: reverse of (x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING) and (-y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING)
             const clickX = event.offsetX;
             const clickY = event.offsetY;
             
             const gridX = Math.round((clickX - (CANVAS_CENTER + CANVAS_PADDING)) / GRID_SIZE);
             const gridY = Math.round(-(clickY - (CANVAS_CENTER + CANVAS_PADDING)) / GRID_SIZE);
             
             // Get current Z-level from filter, or default to 0
             const zFilter = document.getElementById('zLevelFilter').value;
             const gridZ = (zFilter === 'all') ? 0 : parseInt(zFilter);
             
             // Check if room already exists at these coordinates
             const existingRoom = rooms.find(r => r.x === gridX && r.y === gridY && (r.z || 0) === gridZ);
             if (existingRoom) {
                 // If room exists, open editor instead
                 openRoomEditor(existingRoom);
                 return;
             }
             
             // Auto-increment room_id
             const nextRoomId = getNextRoomId();
             
             // Get current area filter
             const areaFilter = document.getElementById('area-filter')?.value || null;
             let selectedAreaId = null;
             
             // If filtering by a specific area, use that area for new rooms
             if (areaFilter) {
                 const selectedArea = areas.find(a => a.area_id === areaFilter);
                 if (selectedArea) {
                     selectedAreaId = selectedArea.id;
                 }
             }
             
             // Create room immediately with default values (no exits/connections)
             const formData = {
                 room_id: nextRoomId,
                 name: `Room ${nextRoomId.replace('room_', '')}`,
                 description: 'A new room.',
                 area_id: selectedAreaId,
                 x: gridX,
                 y: gridY,
                 z: gridZ,
                 exits: {} // Empty object - no exits at all
             };
             
             try {
                const response = await fetch(`${API_BASE}/api/rooms`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });
                
                if (response.ok) {
                    const createdRoom = await response.json();
                    
                    // Add to undo history
                    addToUndoHistory({
                        type: 'create',
                        room: createdRoom
                    });
                    
                    loadRooms(); // Reload rooms to show new room
                } else {
                    const error = await response.json();
                    alert('Error creating room: ' + (error.error || 'Unknown error'));
                }
             } catch (error) {
                 console.error('Error creating room:', error);
                 alert('Error creating room');
             }
         }
         
         // Get next available room ID (finds first gap or increments max)
         function getNextRoomId() {
             if (rooms.length === 0) {
                 return 'room_001';
             }
             
             // Extract room numbers and sort
             const roomNumbers = rooms
                 .map(r => r.room_id)
                 .filter(id => id.startsWith('room_'))
                 .map(id => parseInt(id.replace('room_', '')))
                 .filter(num => !isNaN(num))
                 .sort((a, b) => a - b);
             
             if (roomNumbers.length === 0) {
                 return 'room_001';
             }
             
             // Find first gap in sequence (recycle deleted IDs)
             for (let i = 1; i <= roomNumbers[roomNumbers.length - 1]; i++) {
                 if (!roomNumbers.includes(i)) {
                     return `room_${String(i).padStart(3, '0')}`;
                 }
             }
             
             // No gaps found, increment max
             const maxNumber = Math.max(...roomNumbers);
             const nextNumber = maxNumber + 1;
             
             // Pad with zeros to 3 digits
             return `room_${String(nextNumber).padStart(3, '0')}`;
        }
        
        // Add new room
         function addRoom(x = 0, y = 0, z = 0) {
            selectedRoom = null;
            
            // Clear form
            document.getElementById('roomForm').reset();
             document.getElementById('roomX').value = x;
             document.getElementById('roomY').value = y;
             document.getElementById('roomZ').value = z;
            
            // Hide delete button
            document.getElementById('deleteBtn').style.display = 'none';
            
            // Update selection display
            updateSelectionDisplay();
            
            // Update auto room toggle state
            updateAutoRoomToggle();
            
            roomModal.show();
         }
        
        // Handle exit checkbox change
        async function handleExitChange(direction, isChecked) {
            const result = await checkExitDestination(direction, isChecked);
            
            if (!result) {
                // User declined to create room, uncheck the box
                const checkboxId = `exit${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
                document.getElementById(checkboxId).checked = false;
            }
        }
        
        // Select all exits
        async function selectAllExits() {
            const directions = ['north', 'south', 'east', 'west', 'up', 'down'];
            
            for (const direction of directions) {
                const checkboxId = `exit${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
                const checkbox = document.getElementById(checkboxId);
                
                if (!checkbox.checked) {
                    checkbox.checked = true;
                    // Trigger the change handler to validate/create rooms if needed
                    await handleExitChange(direction, true);
                }
            }
        }
        
        // Clear all exits
        function clearAllExits() {
            const directions = ['north', 'south', 'east', 'west', 'up', 'down'];
            
            directions.forEach(direction => {
                const checkboxId = `exit${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
                const checkbox = document.getElementById(checkboxId);
                checkbox.checked = false;
            });
        }
        
        // Auto select exits where adjacent rooms exist
        function autoSelectExits() {
            const x = parseInt(document.getElementById('roomX').value);
            const y = parseInt(document.getElementById('roomY').value);
            const z = parseInt(document.getElementById('roomZ').value);
            
            const directionOffsets = {
                'north': { x: 0, y: 1, z: 0 },
                'south': { x: 0, y: -1, z: 0 },
                'east': { x: 1, y: 0, z: 0 },
                'west': { x: -1, y: 0, z: 0 },
                'up': { x: 0, y: 0, z: 1 },
                'down': { x: 0, y: 0, z: -1 }
            };
            
            let selectedCount = 0;
            
            Object.entries(directionOffsets).forEach(([direction, offset]) => {
                const targetX = x + offset.x;
                const targetY = y + offset.y;
                const targetZ = z + offset.z;
                
                // Check if room exists at target coordinates
                const targetRoom = rooms.find(r => 
                    r.x === targetX && r.y === targetY && (r.z || 0) === targetZ
                );
                
                const checkboxId = `exit${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
                const checkbox = document.getElementById(checkboxId);
                
                if (targetRoom) {
                    checkbox.checked = true;
                    selectedCount++;
                } else {
                    checkbox.checked = false;
                }
            });
            
            console.log(`Auto-selected ${selectedCount} exit(s) based on adjacent rooms`);
        }
        
        // Check if exit destination exists, offer to create if not
        async function checkExitDestination(direction, isChecked) {
            if (!isChecked) return true; // Allow unchecking exits
            
            const x = parseInt(document.getElementById('roomX').value);
            const y = parseInt(document.getElementById('roomY').value);
            const z = parseInt(document.getElementById('roomZ').value);
            
            // Calculate target coordinates based on direction
            const directionOffsets = {
                'north': { x: 0, y: 1, z: 0 },
                'south': { x: 0, y: -1, z: 0 },
                'east': { x: 1, y: 0, z: 0 },
                'west': { x: -1, y: 0, z: 0 },
                'up': { x: 0, y: 0, z: 1 },
                'down': { x: 0, y: 0, z: -1 }
            };
            
            const offset = directionOffsets[direction];
            const targetX = x + offset.x;
            const targetY = y + offset.y;
            const targetZ = z + offset.z;
            
            // Check if room exists at target coordinates
            const targetRoom = rooms.find(r => 
                r.x === targetX && r.y === targetY && (r.z || 0) === targetZ
            );
            
            if (!targetRoom) {
                const create = confirm(
                    `No room exists ${direction} at coordinates (${targetX}, ${targetY}, ${targetZ}).\n\n` +
                    `Would you like to create a new room there?`
                );
                
                if (create) {
                    const nextRoomId = getNextRoomId();
                    
                    // Get current area filter to assign to new room
                    const areaFilter = document.getElementById('area-filter')?.value || null;
                    let selectedAreaId = null;
                    
                    if (areaFilter) {
                        const selectedArea = areas.find(a => a.area_id === areaFilter);
                        if (selectedArea) {
                            selectedAreaId = selectedArea.id;
                        }
                    }
                    
                    const newRoomData = {
                        room_id: nextRoomId,
                        name: `Room ${nextRoomId.replace('room_', '')}`,
                        description: 'A new room.',
                        area_id: selectedAreaId,
                        x: targetX,
                        y: targetY,
                        z: targetZ,
                        exits: {} // Empty object - no exits at all
                    };
                    
                    try {
                        const response = await fetch(`${API_BASE}/api/rooms`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(newRoomData)
                        });
                        
                        if (response.ok) {
                            await loadRooms(); // Reload rooms to show new room
                            return true;
                        } else {
                            alert('Error creating room');
                            return false;
                        }
                    } catch (error) {
                        console.error('Error creating room:', error);
                        alert('Error creating room');
                        return false;
                    }
                } else {
                    return false; // User declined, don't set exit
                }
            }
            
            return true; // Room exists or was created
        }
        
        // Save room
        async function saveRoom() {
            const x = parseInt(document.getElementById('roomX').value);
            const y = parseInt(document.getElementById('roomY').value);
            const z = parseInt(document.getElementById('roomZ').value);
            const currentRoomId = document.getElementById('roomId').value;
            
            // Convert exit checkboxes to room_id references
            const directionOffsets = {
                'north': { x: 0, y: 1, z: 0 },
                'south': { x: 0, y: -1, z: 0 },
                'east': { x: 1, y: 0, z: 0 },
                'west': { x: -1, y: 0, z: 0 },
                'up': { x: 0, y: 0, z: 1 },
                'down': { x: 0, y: 0, z: -1 }
            };
            
            const oppositeDirections = {
                'north': 'south',
                'south': 'north',
                'east': 'west',
                'west': 'east',
                'up': 'down',
                'down': 'up'
            };
            
            const exits = {};
            const roomsToUpdate = []; // Track rooms that need reciprocal exit changes
            
            ['north', 'south', 'east', 'west', 'up', 'down'].forEach(direction => {
                const checkboxId = `exit${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
                const isChecked = document.getElementById(checkboxId).checked;
                
                const offset = directionOffsets[direction];
                const targetX = x + offset.x;
                const targetY = y + offset.y;
                const targetZ = z + offset.z;
                
                const targetRoom = rooms.find(r => 
                    r.x === targetX && r.y === targetY && (r.z || 0) === targetZ
                );
                
                if (targetRoom) {
                    if (isChecked) {
                        // Add exit
                        exits[direction] = targetRoom.room_id;
                        
                        // Track this room for reciprocal exit addition
                        roomsToUpdate.push({
                            room: targetRoom,
                            direction: oppositeDirections[direction],
                            targetRoomId: currentRoomId,
                            add: true
                        });
                    } else {
                        // Exit unchecked - remove reciprocal exit if it exists
                        if (targetRoom.exits && targetRoom.exits[oppositeDirections[direction]] === currentRoomId) {
                            roomsToUpdate.push({
                                room: targetRoom,
                                direction: oppositeDirections[direction],
                                targetRoomId: currentRoomId,
                                add: false
                            });
                        }
                    }
                }
            });
            
            const formData = {
                room_id: currentRoomId,
                name: document.getElementById('roomName').value,
                description: document.getElementById('roomDescription').value,
                area_id: document.getElementById('areaSelect').value || null,
                x: x,
                y: y,
                z: z,
                exits: exits,
                lighting: document.getElementById('roomLighting').value
            };
            
            try {
                let response;
                let previousState = null;
                
                if (selectedRoom) {
                    // Save previous state for undo
                    previousState = JSON.parse(JSON.stringify(selectedRoom));
                    
                    // Update existing room
                    response = await fetch(`${API_BASE}/api/rooms/${selectedRoom.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(formData)
                    });
                } else {
                    // Create new room
                    response = await fetch(`${API_BASE}/api/rooms`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(formData)
                    });
                }
                
                if (response.ok) {
                    const updatedRoom = await response.json();
                    
                    // Add to undo history if this was an update
                    if (previousState) {
                        addToUndoHistory({
                            type: 'update',
                            room: updatedRoom,
                            previousState: previousState
                        });
                    } else {
                        // This was a create operation
                        addToUndoHistory({
                            type: 'create',
                            room: updatedRoom
                        });
                    }
                    
                    // Update reciprocal exits in connected rooms
                    for (const update of roomsToUpdate) {
                        const targetRoom = update.room;
                        const newExits = { ...(targetRoom.exits || {}) };
                        
                        if (update.add) {
                            // Add reciprocal exit
                            newExits[update.direction] = update.targetRoomId;
                        } else {
                            // Remove reciprocal exit
                            delete newExits[update.direction];
                        }
                        
                        try {
                            await fetch(`${API_BASE}/api/rooms/${targetRoom.id}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    room_id: targetRoom.room_id,
                                    name: targetRoom.name,
                                    description: targetRoom.description,
                                    area_id: targetRoom.area_id,
                                    x: targetRoom.x,
                                    y: targetRoom.y,
                                    z: targetRoom.z || 0,
                                    exits: newExits
                                })
                            });
                        } catch (error) {
                            console.error('Error updating reciprocal exit:', error);
                        }
                    }
                    
                    roomModal.hide();
                    await loadRooms(); // Reload rooms
                    renderMap(); // Redraw entire map with all connection lines
                    
                    // Update selectedRoom reference after reload
                    if (selectedRoom) {
                        selectedRoom = rooms.find(r => r.id === selectedRoom.id) || selectedRoom;
                    }
                    updateSelectionDisplay();
                } else {
                    alert('Error saving room');
                }
            } catch (error) {
                console.error('Error saving room:', error);
                alert('Error saving room');
            }
        }
        
        // Delete room
        async function deleteRoom() {
            if (!selectedRoom) return;
            
            if (confirm('Are you sure you want to delete this room?')) {
                // Save room state before deleting
                const roomToDelete = JSON.parse(JSON.stringify(selectedRoom));
                
                try {
                    const response = await fetch(`${API_BASE}/api/rooms/${selectedRoom.id}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.ok) {
                        // Add to undo history
                        addToUndoHistory({
                            type: 'delete',
                            room: roomToDelete
                        });
                        
                        roomModal.hide();
                        await loadRooms(); // Reload rooms
                        renderMap(); // Redraw entire map
                    } else {
                        alert('Error deleting room');
                    }
                } catch (error) {
                    console.error('Error deleting room:', error);
                    alert('Error deleting room');
                }
            }
        }
        
        // Save map - export to JSON
        async function saveMap() {
            try {
                // Get all rooms from database
                const response = await fetch(`${API_BASE}/api/rooms`);
                if (!response.ok) {
                    alert('Error fetching rooms from database');
                    return;
                }
                
                const allRooms = await response.json();
                
                // Convert to rooms.json format
                const roomsData = {
                    rooms: {}
                };
                
                allRooms.forEach(room => {
                    roomsData.rooms[room.room_id] = {
                        room_id: room.room_id,
                        area_id: room.area_id ? areas.find(a => a.id === room.area_id)?.area_id : null,
                        x_coord: room.x,
                        y_coord: room.y,
                        z_coord: room.z,
                        name: room.name,
                        description: room.description,
                        short_description: room.description,
                        exits: room.exits || {},
                        items: [],
                        npcs: [],
                        lighting: 'normal',
                        temperature: 'normal',
                        weather_effects: [],
                        is_safe: false,
                        is_indoors: false,
                        is_water: false,
                        is_air: false
                    };
                });
                
                // Create download
                const dataStr = JSON.stringify(roomsData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `rooms_export_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert(`Map exported successfully! ${allRooms.length} rooms saved.`);
            } catch (error) {
                console.error('Error saving map:', error);
                alert('Error exporting map');
            }
        }
        
        // Handle keyboard shortcuts
        function handleKeyPress(event) {
            // Enter key in Room Editor - save room
            if (event.key === 'Enter' && (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA')) {
                const modal = document.getElementById('roomModal');
                if (modal && modal.classList.contains('show')) {
                    event.preventDefault();
                    saveRoom();
                    return;
                }
            }
            
            // Don't trigger other shortcuts if user is typing in an input field
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }
            
            // Escape key to deselect rooms
            if (event.key === 'Escape') {
                clearMultiSelection();
                return;
            }
            
            // Ctrl+Z for undo
            if (event.ctrlKey && event.key === 'z') {
                event.preventDefault();
                undoLastAction();
                return;
            }
            
            // Delete key to delete selected rooms
            if (event.key === 'Delete') {
                // Handle multi-selection deletion
                if (multiSelectedRooms.length > 0) {
                    deleteSelectedRooms();
                }
                // Handle single room deletion
                else if (selectedRoom) {
                    deleteSingleSelectedRoom();
                }
            }
            
            // Numpad handling for Auto Room mode
            if (autoRoomMode) {
                console.log('Auto Room Mode active - key pressed:', event.key, 'code:', event.code);
                console.log('Selected room:', selectedRoom ? selectedRoom.room_id : 'none');
                console.log('Multi-selected count:', multiSelectedRooms.length);
            }
            
            if (autoRoomMode && selectedRoom && multiSelectedRooms.length <= 1) {
                // Map numpad codes directly to directions
                const numpadCodeMap = {
                    'Numpad8': { x: 0, y: 1, z: 0, name: 'north' },
                    'Numpad2': { x: 0, y: -1, z: 0, name: 'south' },
                    'Numpad6': { x: 1, y: 0, z: 0, name: 'east' },
                    'Numpad4': { x: -1, y: 0, z: 0, name: 'west' },
                    'Numpad9': { x: 1, y: 1, z: 0, name: 'northeast' },
                    'Numpad7': { x: -1, y: 1, z: 0, name: 'northwest' },
                    'Numpad3': { x: 1, y: -1, z: 0, name: 'southeast' },
                    'Numpad1': { x: -1, y: -1, z: 0, name: 'southwest' },
                    'NumpadAdd': { x: 0, y: 0, z: 1, name: 'up' },
                    'NumpadSubtract': { x: 0, y: 0, z: -1, name: 'down' }
                };
                
                // Also accept regular number keys as fallback
                const keyMap = {
                    '8': { x: 0, y: 1, z: 0, name: 'north' },
                    '2': { x: 0, y: -1, z: 0, name: 'south' },
                    '6': { x: 1, y: 0, z: 0, name: 'east' },
                    '4': { x: -1, y: 0, z: 0, name: 'west' },
                    '9': { x: 1, y: 1, z: 0, name: 'northeast' },
                    '7': { x: -1, y: 1, z: 0, name: 'northwest' },
                    '3': { x: 1, y: -1, z: 0, name: 'southeast' },
                    '1': { x: -1, y: -1, z: 0, name: 'southwest' },
                    '+': { x: 0, y: 0, z: 1, name: 'up' },
                    '-': { x: 0, y: 0, z: -1, name: 'down' }
                };
                
                let direction = null;
                
                // Try event.code first (most reliable for numpad)
                if (event.code && numpadCodeMap[event.code]) {
                    direction = numpadCodeMap[event.code];
                    console.log('Matched numpad code:', event.code, 'direction:', direction.name);
                }
                // Fallback to event.key
                else if (keyMap[event.key]) {
                    direction = keyMap[event.key];
                    console.log('Matched key:', event.key, 'direction:', direction.name);
                }
                
                if (direction) {
                    event.preventDefault();
                    console.log('Creating auto room in direction:', direction.name);
                    createAutoRoom(direction);
                    return;
                }
            }
        }
        
        // Delete single selected room
        async function deleteSingleSelectedRoom() {
            if (!selectedRoom) return;
            
            if (!confirm(`Are you sure you want to delete ${selectedRoom.name}?`)) {
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/rooms/${selectedRoom.id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    selectedRoom = null;
                    await loadRooms();
                    renderMap();
                    updateSelectionDisplay();
                    updateAutoRoomToggle();
                } else {
                    alert('Error deleting room');
                }
            } catch (error) {
                console.error('Error deleting room:', error);
                alert('Error deleting room');
            }
        }
        
        // Handle room drag start
        function handleRoomDragStart(event, room, node) {
            // Only allow drag with Ctrl key held
            if (event.ctrlKey) {
                event.preventDefault(); // Prevent default drag behavior
                event.stopPropagation(); // Prevent selection
                
                isDraggingRoom = true;
                draggedRoom = room;
                draggedNode = node;
                
                const nodeRect = node.getBoundingClientRect();
                
                dragOffset = {
                    x: event.clientX - nodeRect.left,
                    y: event.clientY - nodeRect.top
                };
                
                // Hide tooltip during drag
                hideTooltip();
                
                // Check if this room is part of a multi-selection
                if (multiSelectedRooms.includes(room.id)) {
                    // Dragging multiple rooms - collect all selected rooms and their nodes
                    draggedRooms = multiSelectedRooms.map(roomId => rooms.find(r => r.id === roomId)).filter(r => r);
                    console.log(`Dragging ${draggedRooms.length} rooms from selection:`, draggedRooms.map(r => r.room_id));
                    
                    // Find all nodes for selected rooms
                    draggedNodes = [];
                    const allNodes = document.querySelectorAll('.room-node');
                    allNodes.forEach(n => {
                        const nodeLeft = parseInt(n.style.left);
                        const nodeTop = parseInt(n.style.top);
                        
                        // Find which room this node represents
                        const matchingRoom = draggedRooms.find(r => 
                            r.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING === nodeLeft && 
                            -r.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING === nodeTop
                        );
                        
                        if (matchingRoom) {
                            draggedNodes.push({ node: n, room: matchingRoom });
                            n.style.cursor = 'grabbing';
                        }
                    });
                    console.log(`Found ${draggedNodes.length} nodes for dragging`);
                } else {
                    // Dragging single room
                    draggedRooms = [room];
                    draggedNodes = [{ node: node, room: room }];
                    node.style.cursor = 'grabbing';
                }
            }
        }
        
        // Handle room drop
        async function handleRoomDrop(event) {
            if (!isDraggingRoom || !draggedRoom || !draggedNode) return;
            
            // Always set this to prevent click event
            justFinishedDrag = true;
            
            const canvas = document.getElementById('map-canvas');
            const rect = canvas.getBoundingClientRect();
            const dropX = event.clientX - rect.left + canvas.scrollLeft;
            const dropY = event.clientY - rect.top + canvas.scrollTop;
            
            // Calculate new grid position for the primary dragged room
            const newGridX = Math.round((dropX - dragOffset.x - 1000) / 50);
            const newGridY = Math.round(-(dropY - dragOffset.y - 1000) / 50);
            
            // Calculate the offset from original position
            const deltaX = newGridX - draggedRoom.x;
            const deltaY = newGridY - draggedRoom.y;
            
            // Check if position is different
            if (deltaX !== 0 || deltaY !== 0) {
                
                // Check for coordinate conflicts for all rooms being moved
                let hasConflict = false;
                for (const roomToMove of draggedRooms) {
                    const targetX = roomToMove.x + deltaX;
                    const targetY = roomToMove.y + deltaY;
                    const targetZ = roomToMove.z || 0;
                    
                    const existingRoom = rooms.find(r => 
                        !draggedRooms.find(dr => dr.id === r.id) && // Not one of the rooms being moved
                        r.x === targetX && 
                        r.y === targetY && 
                        (r.z || 0) === targetZ
                    );
                    
                    if (existingRoom) {
                        alert(`Cannot move rooms: position (${targetX}, ${targetY}, ${targetZ}) is occupied by ${existingRoom.name}`);
                        hasConflict = true;
                        break;
                    }
                }
                
                if (!hasConflict) {
                    // Update all room positions
                    console.log(`Moving ${draggedRooms.length} room(s)`);
                    if (draggedRooms.length === 1) {
                        // Single room - use the full update with exit cleanup
                        const newX = draggedRooms[0].x + deltaX;
                        const newY = draggedRooms[0].y + deltaY;
                        const newZ = draggedRooms[0].z || 0;
                        await updateRoomPosition(draggedRooms[0], newX, newY, newZ);
                    } else {
                        // Multiple rooms - simple position update without exit cleanup
                        // (exits remain intact since rooms move together)
                        for (const roomToMove of draggedRooms) {
                            const newX = roomToMove.x + deltaX;
                            const newY = roomToMove.y + deltaY;
                            const newZ = roomToMove.z || 0;
                            
                            try {
                                await fetch(`/api/rooms/${roomToMove.id}`, {
                                    method: 'PUT',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        room_id: roomToMove.room_id,
                                        name: roomToMove.name,
                                        description: roomToMove.description,
                                        area_id: roomToMove.area_id,
                                        x: newX,
                                        y: newY,
                                        z: newZ,
                                        exits: roomToMove.exits || {}
                                    })
                                });
                            } catch (error) {
                                console.error(`Error updating room ${roomToMove.room_id}:`, error);
                            }
                        }
                    }
                }
            }
            
            // Reset drag state for all nodes
            draggedNodes.forEach(({ node }) => {
                node.style.cursor = 'grab';
                node.style.opacity = '1';
                node.style.zIndex = '';
            });
            
            isDraggingRoom = false;
            draggedRoom = null;
            draggedNode = null;
            draggedRooms = [];
            draggedNodes = [];
            
            // Redraw map
            await loadRooms();
            renderMap();
        }
        
        // Update room position and clean up exits
        async function updateRoomPosition(room, newX, newY, newZ) {
            const directionOffsets = {
                'north': { x: 0, y: 1, z: 0 },
                'south': { x: 0, y: -1, z: 0 },
                'east': { x: 1, y: 0, z: 0 },
                'west': { x: -1, y: 0, z: 0 },
                'up': { x: 0, y: 0, z: 1 },
                'down': { x: 0, y: 0, z: -1 }
            };
            
            const oppositeDirections = {
                'north': 'south',
                'south': 'north',
                'east': 'west',
                'west': 'east',
                'up': 'down',
                'down': 'up'
            };
            
            // Clean up old reciprocal exits from connected rooms
            const oldExits = room.exits || {};
            for (const [direction, targetRoomId] of Object.entries(oldExits)) {
                const targetRoom = rooms.find(r => r.room_id === targetRoomId);
                if (targetRoom && targetRoom.exits) {
                    const oppositeDir = oppositeDirections[direction];
                    if (targetRoom.exits[oppositeDir] === room.room_id) {
                        // Remove reciprocal exit
                        const newTargetExits = { ...targetRoom.exits };
                        delete newTargetExits[oppositeDir];
                        
                        try {
                            await fetch(`/api/rooms/${targetRoom.id}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    room_id: targetRoom.room_id,
                                    name: targetRoom.name,
                                    description: targetRoom.description,
                                    area_id: targetRoom.area_id,
                                    x: targetRoom.x,
                                    y: targetRoom.y,
                                    z: targetRoom.z || 0,
                                    exits: newTargetExits
                                })
                            });
                        } catch (error) {
                            console.error('Error removing reciprocal exit:', error);
                        }
                    }
                }
            }
            
            // Validate which exits are still valid at new position
            const validExits = {};
            for (const [direction, targetRoomId] of Object.entries(oldExits)) {
                const offset = directionOffsets[direction];
                const expectedX = newX + offset.x;
                const expectedY = newY + offset.y;
                const expectedZ = newZ + offset.z;
                
                const targetRoom = rooms.find(r => r.room_id === targetRoomId);
                if (targetRoom && 
                    targetRoom.x === expectedX && 
                    targetRoom.y === expectedY && 
                    (targetRoom.z || 0) === expectedZ) {
                    // Exit is still valid
                    validExits[direction] = targetRoomId;
                    
                    // Re-add reciprocal exit
                    const oppositeDir = oppositeDirections[direction];
                    const newTargetExits = { ...(targetRoom.exits || {}) };
                    newTargetExits[oppositeDir] = room.room_id;
                    
                    try {
                        await fetch(`/api/rooms/${targetRoom.id}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                room_id: targetRoom.room_id,
                                name: targetRoom.name,
                                description: targetRoom.description,
                                area_id: targetRoom.area_id,
                                x: targetRoom.x,
                                y: targetRoom.y,
                                z: targetRoom.z || 0,
                                exits: newTargetExits
                            })
                        });
                    } catch (error) {
                        console.error('Error re-adding reciprocal exit:', error);
                    }
                }
            }
            
            // Update room with new position and valid exits
            try {
                await fetch(`/api/rooms/${room.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        room_id: room.room_id,
                        name: room.name,
                        description: room.description,
                        area_id: room.area_id,
                        x: newX,
                        y: newY,
                        z: newZ,
                        exits: validExits
                    })
                });
            } catch (error) {
                console.error('Error updating room position:', error);
                alert('Error updating room position');
            }
        }
        
        // Handle selection start
        function handleSelectionStart(event) {
            // Don't start selection if dragging a room
            if (isDraggingRoom) return;
            
            // Only start selection if clicking on empty canvas (not on room nodes)
            if (event.target.classList.contains('room-node')) {
                return;
            }
            
            // Check if Shift key is held down for multi-select
            if (!event.shiftKey) {
                clearMultiSelection();
            }
            
            isSelecting = true;
            const rect = event.currentTarget.getBoundingClientRect();
            selectionStart = {
                x: event.clientX - rect.left + event.currentTarget.scrollLeft,
                y: event.clientY - rect.top + event.currentTarget.scrollTop
            };
            
            // Create or reuse selection box
            if (!selectionBox) {
                selectionBox = document.createElement('div');
                selectionBox.className = 'selection-box';
                event.currentTarget.appendChild(selectionBox);
            }
            
            // Reset and show selection box
            selectionBox.style.left = selectionStart.x + 'px';
            selectionBox.style.top = selectionStart.y + 'px';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';
        }
        
        // Handle canvas drag (either selection or room move)
        function handleCanvasDrag(event) {
            if (isDraggingRoom && draggedNode) {
                // Handle room drag (single or multiple)
                const rect = event.currentTarget.getBoundingClientRect();
                const mouseX = event.clientX - rect.left + event.currentTarget.scrollLeft;
                const mouseY = event.clientY - rect.top + event.currentTarget.scrollTop;
                
                // Calculate how much the primary dragged node has moved
                const newLeft = mouseX - dragOffset.x;
                const newTop = mouseY - dragOffset.y;
                const deltaX = newLeft - (draggedRoom.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING);
                const deltaY = newTop - (-draggedRoom.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING);
                
                // Move all dragged nodes by the same delta
                draggedNodes.forEach(({ node, room }) => {
                    const baseLeft = room.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING;
                    const baseTop = -room.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING;
                    
                    node.style.left = (baseLeft + deltaX) + 'px';
                    node.style.top = (baseTop + deltaY) + 'px';
                    node.style.opacity = '0.6';
                    node.style.zIndex = '1000';
                });
                
            } else if (isSelecting && selectionBox) {
                // Handle selection drag
                const rect = event.currentTarget.getBoundingClientRect();
                const currentX = event.clientX - rect.left + event.currentTarget.scrollLeft;
                const currentY = event.clientY - rect.top + event.currentTarget.scrollTop;
                
                const width = Math.abs(currentX - selectionStart.x);
                const height = Math.abs(currentY - selectionStart.y);
                const left = Math.min(currentX, selectionStart.x);
                const top = Math.min(currentY, selectionStart.y);
                
                selectionBox.style.left = left + 'px';
                selectionBox.style.top = top + 'px';
                selectionBox.style.width = width + 'px';
                selectionBox.style.height = height + 'px';
            }
        }
        
        // Handle canvas mouse up (either selection or room drop)
        function handleCanvasMouseUp(event) {
            if (isDraggingRoom) {
                handleRoomDrop(event);
            } else {
                handleSelectionEnd(event);
            }
        }
        
        // Handle selection end
        function handleSelectionEnd(event) {
            if (!isSelecting) return;
            
            isSelecting = false;
            
            if (selectionBox) {
                const width = parseFloat(selectionBox.style.width);
                const height = parseFloat(selectionBox.style.height);
                
                // Check if this was actually a drag (not just a click)
                if (width > 5 || height > 5) {
                    justFinishedDrag = true;
                    
                    // Get selection box bounds
                    const boxRect = {
                        left: parseFloat(selectionBox.style.left),
                        top: parseFloat(selectionBox.style.top),
                        right: parseFloat(selectionBox.style.left) + width,
                        bottom: parseFloat(selectionBox.style.top) + height
                    };
                    
                    // Find rooms within selection box
                    const zFilter = document.getElementById('zLevelFilter').value;
                    const filteredRooms = zFilter === 'all' 
                        ? rooms 
                        : rooms.filter(r => (r.z || 0) === parseInt(zFilter));
                    
                    filteredRooms.forEach(room => {
                        const roomLeft = room.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING;
                        const roomTop = -room.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING;
                        const roomRight = roomLeft + 40;
                        const roomBottom = roomTop + 40;
                        
                        // Check if room overlaps with selection box
                        if (roomLeft < boxRect.right && roomRight > boxRect.left &&
                            roomTop < boxRect.bottom && roomBottom > boxRect.top) {
                            if (!multiSelectedRooms.includes(room.id)) {
                                multiSelectedRooms.push(room.id);
                            }
                        }
                    });
                    
                    // Update visual selection
                    updateMultiSelection();
                }

                if(selectionBox != null) {
                    // Remove selection box
                    selectionBox.style.display = 'none';
                }
            }
        }
        
        // Update visual selection
        function updateMultiSelection() {
            // Redraw map to update multi-selected visual states
            renderMap();
            
            // Show/hide and enable/disable action buttons
            const copyBtn = document.getElementById('copySelectedBtn');
            const autoExitBtn = document.getElementById('autoExitBtn');
            
            if (multiSelectedRooms.length > 0) {
                copyBtn.style.display = 'inline-block';
                autoExitBtn.disabled = false;
            } else {
                copyBtn.style.display = 'none';
                autoExitBtn.disabled = true;
            }
            
            // Update selection display
            updateSelectionDisplay();
            
            // Update auto room toggle state
            updateAutoRoomToggle();
        }
        
        // Clear multi selection
        function clearMultiSelection() {
            multiSelectedRooms = [];
            selectedRoom = null; // Also clear single selection
            updateMultiSelection();
            // updateMultiSelection already calls updateSelectionDisplay
        }
        
        // Copy selected rooms
        async function copySelectedRooms() {
            if (multiSelectedRooms.length === 0) {
                alert('No rooms selected');
                return;
            }
            
            const offset = prompt('Enter offset for copied rooms (format: x,y,z)', '1,0,0');
            if (!offset) return;
            
            const [dx, dy, dz] = offset.split(',').map(n => parseInt(n.trim()));
            
            if (isNaN(dx) || isNaN(dy) || isNaN(dz)) {
                alert('Invalid offset format. Use: x,y,z');
                return;
            }
            
            for (const roomId of multiSelectedRooms) {
                const room = rooms.find(r => r.id === roomId);
                if (!room) continue;
                
                const nextRoomId = getNextRoomId();
                
                // Preserve the room's area when copying
                const newRoomData = {
                    room_id: nextRoomId,
                    name: room.name + ' (Copy)',
                    description: room.description,
                    area_id: room.area_id,
                    x: room.x + dx,
                    y: room.y + dy,
                    z: (room.z || 0) + dz,
                    exits: {} // Don't copy exits
                };
                
                try {
                    await fetch('/api/rooms', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(newRoomData)
                    });
                } catch (error) {
                    console.error('Error copying room:', error);
                }
            }
            
            await loadRooms();
            renderMap();
            clearMultiSelection();
        }
        
        // Delete selected rooms
        async function deleteSelectedRooms() {
            if (multiSelectedRooms.length === 0) {
                alert('No rooms selected');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete ${multiSelectedRooms.length} room(s)?`)) {
                return;
            }
            
            for (const roomId of multiSelectedRooms) {
                try {
                    await fetch(`/api/rooms/${roomId}`, {
                        method: 'DELETE'
                    });
                } catch (error) {
                    console.error('Error deleting room:', error);
                }
            }
            
            await loadRooms();
            renderMap();
            clearMultiSelection();
        }
        
        // Auto-exit selected rooms
        async function autoExitSelectedRooms() {
            if (multiSelectedRooms.length === 0) {
                alert('No rooms selected');
                return;
            }
            
            if (!confirm(`Auto-detect and set exits for ${multiSelectedRooms.length} selected room(s)?`)) {
                return;
            }
            
            const directionOffsets = {
                'north': { x: 0, y: 1, z: 0 },
                'south': { x: 0, y: -1, z: 0 },
                'east': { x: 1, y: 0, z: 0 },
                'west': { x: -1, y: 0, z: 0 },
                'up': { x: 0, y: 0, z: 1 },
                'down': { x: 0, y: 0, z: -1 }
            };
            
            const oppositeDirections = {
                'north': 'south',
                'south': 'north',
                'east': 'west',
                'west': 'east',
                'up': 'down',
                'down': 'up'
            };
            
            let totalExitsAdded = 0;
            
            for (const roomId of multiSelectedRooms) {
                const room = rooms.find(r => r.id === roomId);
                if (!room) continue;
                
                // Preserve existing exits
                const newExits = { ...(room.exits || {}) };
                const roomsToUpdate = [];
                
                // Check all six directions for adjacent rooms
                for (const [direction, offset] of Object.entries(directionOffsets)) {
                    // Skip if exit already exists in this direction
                    if (newExits[direction]) {
                        continue;
                    }
                    
                    const targetX = room.x + offset.x;
                    const targetY = room.y + offset.y;
                    const targetZ = (room.z || 0) + offset.z;
                    
                    // Find room at target coordinates
                    const targetRoom = rooms.find(r => 
                        r.x === targetX && r.y === targetY && (r.z || 0) === targetZ
                    );
                    
                    if (targetRoom) {
                        // Add exit to target room (only if it didn't exist)
                        newExits[direction] = targetRoom.room_id;
                        totalExitsAdded++;
                        
                        // Also add reciprocal exit in target room (if it doesn't exist)
                        const oppositeDir = oppositeDirections[direction];
                        if (!targetRoom.exits || !targetRoom.exits[oppositeDir]) {
                            roomsToUpdate.push({
                                room: targetRoom,
                                direction: oppositeDir,
                                targetRoomId: room.room_id
                            });
                        }
                    }
                }
                
                // Update the current room with new exits
                try {
                    await fetch(`/api/rooms/${room.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            room_id: room.room_id,
                            name: room.name,
                            description: room.description,
                            area_id: room.area_id,
                            x: room.x,
                            y: room.y,
                            z: room.z || 0,
                            exits: newExits
                        })
                    });
                    
                    // Update reciprocal exits in connected rooms
                    for (const update of roomsToUpdate) {
                        const targetRoom = update.room;
                        const newTargetExits = { ...(targetRoom.exits || {}) };
                        
                        // Only add if it doesn't already exist
                        if (!newTargetExits[update.direction]) {
                            newTargetExits[update.direction] = update.targetRoomId;
                            totalExitsAdded++;
                        }
                        
                        try {
                            await fetch(`/api/rooms/${targetRoom.id}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    room_id: targetRoom.room_id,
                                    name: targetRoom.name,
                                    description: targetRoom.description,
                                    area_id: targetRoom.area_id,
                                    x: targetRoom.x,
                                    y: targetRoom.y,
                                    z: targetRoom.z || 0,
                                    exits: newTargetExits
                                })
                            });
                        } catch (error) {
                            console.error('Error updating reciprocal exit:', error);
                        }
                    }
                } catch (error) {
                    console.error(`Error auto-exiting room ${room.room_id}:`, error);
                }
            }
            
            await loadRooms();
            renderMap();
            clearMultiSelection();
            
            if (totalExitsAdded > 0) {
                alert(`Auto-exit complete! Added ${totalExitsAdded} new exit(s) to ${multiSelectedRooms.length} room(s). Existing exits were preserved.`);
            } else {
                alert(`Auto-exit complete! No new exits added - all adjacent exits already exist.`);
            }
        }
        
        // Handle context menu (right-click)
        function handleContextMenu(event) {
            // Check if right-click is on a room-node
            const target = event.target;
            const isRoomNode = target.classList.contains('room-node') || target.closest('.room-node');
            
            if (isRoomNode) {
                event.preventDefault();
                
                const roomNode = target.classList.contains('room-node') ? target : target.closest('.room-node');
                const nodeLeft = parseInt(roomNode.style.left);
                const nodeTop = parseInt(roomNode.style.top);
                
                // Find the room this node represents
                const clickedRoom = rooms.find(r => 
                    r.x * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING === nodeLeft && 
                    -r.y * GRID_SIZE + CANVAS_CENTER + CANVAS_PADDING === nodeTop
                );
                
                if (clickedRoom) {
                    // If clicked room is not in multi-selection, select only it
                    if (!multiSelectedRooms.includes(clickedRoom.id)) {
                        multiSelectedRooms = [clickedRoom.id];
                        selectedRoom = clickedRoom;
                        updateMultiSelection();
                    }
                    
                    // Show context menu at mouse position
                    const contextMenu = document.getElementById('contextMenu');
                    contextMenu.style.display = 'block';
                    contextMenu.style.left = event.pageX + 'px';
                    contextMenu.style.top = event.pageY + 'px';
                }
            }
        }
        
        // Hide context menu
        function hideContextMenu() {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'none';
        }
        
        // Change selected room names
        async function changeSelectedRoomNames() {
            hideContextMenu();
            
            const roomsToChange = multiSelectedRooms.length > 0 
                ? multiSelectedRooms.map(id => rooms.find(r => r.id === id)).filter(r => r)
                : (selectedRoom ? [selectedRoom] : []);
            
            if (roomsToChange.length === 0) {
                alert('No rooms selected');
                return;
            }
            
            if (roomsToChange.length === 1) {
                // Single room - prompt for new name
                const room = roomsToChange[0];
                const newName = prompt(`Enter new name for room "${room.name}":`, room.name);
                
                if (newName && newName.trim() && newName !== room.name) {
                    try {
                        const response = await fetch(`/api/rooms/${room.id}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                room_id: room.room_id,
                                name: newName.trim(),
                                description: room.description,
                                area_id: room.area_id,
                                x: room.x,
                                y: room.y,
                                z: room.z || 0,
                                exits: room.exits,
                                lighting: room.lighting
                            })
                        });
                        
                        if (response.ok) {
                            await loadRooms();
                            renderMap();
                        } else {
                            alert('Error updating room name');
                        }
                    } catch (error) {
                        console.error('Error updating room name:', error);
                        alert('Error updating room name');
                    }
                }
            } else {
                // Multiple rooms - prompt for name
                const newName = prompt(
                    `Enter name for ${roomsToChange.length} selected rooms:`,
                    'Room'
                );
                
                if (newName && newName.trim()) {
                    let count = 0;
                    for (const room of roomsToChange) {
                        count++;
                        
                        try {
                            await fetch(`/api/rooms/${room.id}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    room_id: room.room_id,
                                    name: newName.trim(),
                                    description: room.description,
                                    area_id: room.area_id,
                                    x: room.x,
                                    y: room.y,
                                    z: room.z || 0,
                                    exits: room.exits,
                                    lighting: room.lighting
                                })
                            });
                        } catch (error) {
                            console.error(`Error updating room ${room.room_id}:`, error);
                        }
                    }
                    
                    await loadRooms();
                    renderMap();
                    alert(`Updated names for ${count} room(s)`);
                }
            }
        }
        
        // Add action to undo history
        function addToUndoHistory(action) {
            undoHistory.push(action);
            
            // Keep only last 3 actions
            if (undoHistory.length > MAX_UNDO_STEPS) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }
        
        // Update undo button state
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            undoBtn.disabled = undoHistory.length === 0;
        }
        
        // Undo last action
        async function undoLastAction() {
            if (undoHistory.length === 0) {
                return;
            }
            
            const action = undoHistory.pop();
            updateUndoButton();
            
            try {
                switch (action.type) {
                    case 'create':
                        // Undo room creation by deleting it
                        await fetch(`/api/rooms/${action.room.id}`, {
                            method: 'DELETE'
                        });
                        break;
                        
                    case 'delete':
                        // Undo deletion by recreating the room
                        await fetch('/api/rooms', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                room_id: action.room.room_id,
                                name: action.room.name,
                                description: action.room.description,
                                area_id: action.room.area_id,
                                x: action.room.x,
                                y: action.room.y,
                                z: action.room.z || 0,
                                exits: action.room.exits || {},
                                lighting: action.room.lighting || 'normal'
                            })
                        });
                        break;
                        
                    case 'update':
                        // Undo update by restoring previous state
                        await fetch(`/api/rooms/${action.room.id}`, {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                room_id: action.previousState.room_id,
                                name: action.previousState.name,
                                description: action.previousState.description,
                                area_id: action.previousState.area_id,
                                x: action.previousState.x,
                                y: action.previousState.y,
                                z: action.previousState.z || 0,
                                exits: action.previousState.exits || {},
                                lighting: action.previousState.lighting || 'normal'
                            })
                        });
                        break;
                        
                    case 'bulk':
                        // Undo bulk operation
                        for (const subAction of action.actions.reverse()) {
                            // Recursively undo each action in the bulk operation
                            undoHistory.push(subAction);
                            await undoLastAction();
                        }
                        break;
                }
                
                await loadRooms();
                renderMap();
                console.log('Undo successful');
            } catch (error) {
                console.error('Error undoing action:', error);
                alert('Error undoing action');
            }
        }
        
        // ==================== Door Management Functions ====================
        
        async function loadKeys() {
            try {
                const response = await fetch('/api/keys');
                availableKeys = await response.json();
                console.log('Loaded keys:', availableKeys.length);
            } catch (error) {
                console.error('Error loading keys:', error);
                availableKeys = [];
            }
        }
        
        function populateKeySelect() {
            const keySelect = document.getElementById('doorKeyId');
            keySelect.innerHTML = '<option value="">No Key Required</option>';
            
            availableKeys.forEach(key => {
                const option = document.createElement('option');
                option.value = key.template_id;
                option.textContent = `${key.name} (${key.template_id})`;
                keySelect.appendChild(option);
            });
        }
        
        function editDoor(direction) {
            if (!selectedRoom) {
                alert('Please select a room first');
                return;
            }
            
            currentDoorDirection = direction;
            document.getElementById('doorDirection').textContent = direction.toUpperCase();
            
            // Populate key select
            populateKeySelect();
            
            // Load existing door data if it exists
            const existingDoor = selectedRoom.doors && selectedRoom.doors[direction];
            
            if (existingDoor) {
                // Edit existing door
                document.getElementById('doorId').value = existingDoor.door_id || '';
                document.getElementById('doorName').value = existingDoor.name || '';
                document.getElementById('doorDescription').value = existingDoor.description || '';
                document.getElementById('doorKeyId').value = existingDoor.key_id || '';
                document.getElementById('doorLockDifficulty').value = existingDoor.lock_difficulty || 0;
                updateLockDifficultyLabel();
                
                // Set flags
                const flags = existingDoor.flags || [];
                document.getElementById('flagClosed').checked = flags.includes('closed');
                document.getElementById('flagLocked').checked = flags.includes('locked');
                document.getElementById('flagPickProof').checked = flags.includes('pick_proof');
                document.getElementById('flagPassProof').checked = flags.includes('pass_proof');
                document.getElementById('flagSecret').checked = flags.includes('secret');
                document.getElementById('flagHidden').checked = flags.includes('hidden');
                document.getElementById('flagNoLock').checked = flags.includes('no_lock');
                document.getElementById('flagNoKnock').checked = flags.includes('no_knock');
                document.getElementById('flagNoClose').checked = flags.includes('no_close');
                
                document.getElementById('deleteDoorBtn').style.display = 'inline-block';
            } else {
                // New door - generate default ID
                const defaultDoorId = `door_${selectedRoom.room_id}_${direction}`;
                document.getElementById('doorId').value = defaultDoorId;
                document.getElementById('doorName').value = '';
                document.getElementById('doorDescription').value = '';
                document.getElementById('doorKeyId').value = '';
                document.getElementById('doorLockDifficulty').value = 0;
                updateLockDifficultyLabel();
                
                // Clear all flags
                document.getElementById('flagClosed').checked = false;
                document.getElementById('flagLocked').checked = false;
                document.getElementById('flagPickProof').checked = false;
                document.getElementById('flagPassProof').checked = false;
                document.getElementById('flagSecret').checked = false;
                document.getElementById('flagHidden').checked = false;
                document.getElementById('flagNoLock').checked = false;
                document.getElementById('flagNoKnock').checked = false;
                document.getElementById('flagNoClose').checked = false;
                
                document.getElementById('deleteDoorBtn').style.display = 'none';
            }
            
            doorModal.show();
        }
        
        function updateLockDifficultyLabel() {
            const difficulty = document.getElementById('doorLockDifficulty').value;
            let label = difficulty;
            
            if (difficulty == 0) {
                label += ' (No Lock)';
            } else if (difficulty <= 25) {
                label += ' (Trivial)';
            } else if (difficulty <= 50) {
                label += ' (Easy)';
            } else if (difficulty <= 75) {
                label += ' (Medium)';
            } else if (difficulty <= 100) {
                label += ' (Hard)';
            } else if (difficulty <= 150) {
                label += ' (Magical)';
            } else if (difficulty <= 200) {
                label += ' (Very Magical)';
            } else {
                label += ' (Nearly Impossible)';
            }
            
            document.getElementById('lockDifficultyValue').textContent = label;
        }
        
        async function saveDoor() {
            if (!selectedRoom || !currentDoorDirection) {
                alert('No room or direction selected');
                return;
            }
            
            // Collect door data
            const doorData = {
                door_id: document.getElementById('doorId').value.trim(),
                name: document.getElementById('doorName').value.trim(),
                description: document.getElementById('doorDescription').value.trim(),
                key_id: document.getElementById('doorKeyId').value,
                lock_difficulty: parseInt(document.getElementById('doorLockDifficulty').value),
                flags: []
            };
            
            // Collect flags
            if (document.getElementById('flagClosed').checked) doorData.flags.push('closed');
            if (document.getElementById('flagLocked').checked) doorData.flags.push('locked');
            if (document.getElementById('flagPickProof').checked) doorData.flags.push('pick_proof');
            if (document.getElementById('flagPassProof').checked) doorData.flags.push('pass_proof');
            if (document.getElementById('flagSecret').checked) doorData.flags.push('secret');
            if (document.getElementById('flagHidden').checked) doorData.flags.push('hidden');
            if (document.getElementById('flagNoLock').checked) doorData.flags.push('no_lock');
            if (document.getElementById('flagNoKnock').checked) doorData.flags.push('no_knock');
            if (document.getElementById('flagNoClose').checked) doorData.flags.push('no_close');
            
            // Validate required fields
            if (!doorData.door_id) {
                alert('Door ID is required');
                return;
            }
            
            if (!doorData.name) {
                alert('Door name is required');
                return;
            }
            
            // Validate locked doors have keys
            if (doorData.flags.includes('locked') && !doorData.key_id) {
                alert('Locked doors must have a key assigned!');
                return;
            }
            
            // Validate conflicting flags
            if (doorData.flags.includes('no_lock') && doorData.flags.includes('locked')) {
                alert('Door cannot have both "No Lock" and "Locked" flags');
                return;
            }
            
            if (doorData.flags.includes('no_close') && doorData.flags.includes('closed')) {
                alert('Door cannot have both "No Close" and "Closed" flags');
                return;
            }
            
            try {
                const response = await fetch(`/api/rooms/${selectedRoom.id}/doors/${currentDoorDirection}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(doorData)
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    alert(`Error: ${result.error}\n${result.details ? result.details.join('\n') : ''}`);
                    return;
                }
                
                // Update local room data
                if (!selectedRoom.doors) {
                    selectedRoom.doors = {};
                }
                selectedRoom.doors[currentDoorDirection] = doorData;
                
                // Update the door button appearance
                updateDoorButtons();
                
                doorModal.hide();
                alert(`Door saved successfully for ${currentDoorDirection} direction`);
            } catch (error) {
                console.error('Error saving door:', error);
                alert('Error saving door');
            }
        }
        
        async function deleteDoor() {
            if (!selectedRoom || !currentDoorDirection) {
                alert('No room or direction selected');
                return;
            }
            
            if (!confirm(`Delete the ${currentDoorDirection} door?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/rooms/${selectedRoom.id}/doors/${currentDoorDirection}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (!response.ok) {
                    alert(`Error: ${result.error}`);
                    return;
                }
                
                // Remove from local room data
                if (selectedRoom.doors && selectedRoom.doors[currentDoorDirection]) {
                    delete selectedRoom.doors[currentDoorDirection];
                }
                
                // Update the door button appearance
                updateDoorButtons();
                
                doorModal.hide();
                alert('Door deleted successfully');
            } catch (error) {
                console.error('Error deleting door:', error);
                alert('Error deleting door');
            }
        }
        
        function updateDoorButtons() {
            const directions = ['north', 'south', 'east', 'west', 'up', 'down'];
            
            directions.forEach(direction => {
                const button = document.querySelector(`button[onclick="editDoor('${direction}')"]`);
                if (button) {
                    if (selectedRoom.doors && selectedRoom.doors[direction]) {
                        button.classList.remove('btn-outline-warning');
                        button.classList.add('btn-warning');
                        button.innerHTML = `<i class="fas fa-door-closed"></i> ${direction.charAt(0).toUpperCase() + direction.slice(1)} Door ✓`;
                    } else {
                        button.classList.remove('btn-warning');
                        button.classList.add('btn-outline-warning');
                        button.innerHTML = `<i class="fas fa-door-closed"></i> ${direction.charAt(0).toUpperCase() + direction.slice(1)} Door`;
                    }
                }
            });
        }
        
        function showDoorHelp() {
            const helpText = `Door System Help:

Lock Difficulty:
- 0: No lock
- 1-100: Normal locks (pickable by thieves)
- 101-255: Magical locks (wizard lock spell)

Door Flags:
- Closed: Door starts closed
- Locked: Door is locked (requires key)
- Pick Proof: Cannot be picked by thieves
- Pass Proof: Cannot pass through at all
- Secret: Hidden door (requires search)
- Hidden: Not visible in room description
- No Lock: Door cannot be locked
- No Knock: Knock spell won't work
- No Close: Door cannot be closed

Important: Locked doors MUST have a key assigned!`;
            
            alert(helpText);
        }
    </script>
</body>
</html>
